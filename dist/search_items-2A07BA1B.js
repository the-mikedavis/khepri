searchNodes=[{"doc":"Khepri database API. This module exposes the database API to manipulate data. The API is mainly made of the functions used to perform simple direct atomic operations and queries on the database: get/1 , put/2 , delete/1 and so on. In addition to that, transaction/1 is the starting point to run transaction functions. However the API to use inside transaction functions is provided by khepri_tx . Functions in this module have simplified return values to cover most frequent use cases. If you need more details about the queried or modified tree nodes, like the ability to distinguish a non-existent tree node from a tree node with no payload, you can use the khepri_adv module. This module also provides functions to start and stop a simple unclustered Khepri store. For more advanced setup and clustering, see khepri_cluster . A Khepri store A Khepri store is one instance of Khepri running inside a Ra cluster (which could be made of a single Erlang node). It is possible to run multiple Khepri stores in parallel by creating multiple Ra clusters. A Khepri store is started and configured with start/0 , start/1 or start/3 . To setup a cluster, see khepri_cluster . When a store is started, a store ID store_id() is returned. This store ID is then used by the rest of this module's API. The returned store ID currently corresponds exactly to the Ra cluster name. It must be an atom though; other types are unsupported. Interacting with the Khepri store The API provides two ways to interact with a Khepri store: Direct atomic function for simple operations Transactions for more complex operations Simple operations are calls like: Queries: get/1 , exists/1 , has_data/1 , etc. Updates: put/2 , delete/1 , etc. Transactions are like Mnesia ones. The caller passes an anonymous function to transaction/1 , etc.: khepri : transaction ( fun ( ) -&gt; khepri_tx : put ( Path , Value ) end ) . Simple operations are more efficient than transactions, but transactions are more flexible.","ref":"khepri.html","title":"khepri","type":"module"},{"doc":"Updates an existing tree node with the given payload only if its data matches the given pattern. Calling this function is the same as calling compare_and_swap(StoreId, PathPattern, DataPattern, Data) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: compare_and_swap/4 , compare_and_swap/5 .","ref":"khepri.html#compare_and_swap/3","title":"khepri.compare_and_swap/3","type":"function"},{"doc":"Updates an existing tree node with the given payload only if its data matches the given pattern. Calling this function is the same as calling compare_and_swap(StoreId, PathPattern, DataPattern, Data, \#{}) . See also: compare_and_swap/5 .","ref":"khepri.html#compare_and_swap/4","title":"khepri.compare_and_swap/4","type":"function"},{"doc":"Updates an existing tree node with the given payload only if its data matches the given pattern. The behavior is the same as put/4 except that if the tree node already exists, an {error, ?khepri_error(mismatching_node, Info)} tuple is returned. Internally, the PathPattern is modified to include an #if_data_matches{pattern = DataPattern} condition on its last component. See also: create/4 , put/4 , update/4 , khepri_adv:compare_and_swap/5 .","ref":"khepri.html#compare_and_swap/5","title":"khepri.compare_and_swap/5","type":"function"},{"doc":"","ref":"khepri.html#compare_and_swap!/3","title":"khepri.compare_and_swap!/3","type":"function"},{"doc":"","ref":"khepri.html#compare_and_swap!/4","title":"khepri.compare_and_swap!/4","type":"function"},{"doc":"","ref":"khepri.html#compare_and_swap!/5","title":"khepri.compare_and_swap!/5","type":"function"},{"doc":"Counts all tree nodes matching the given path pattern. Calling this function is the same as calling count(StoreId, PathPattern) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: count/2 , count/3 .","ref":"khepri.html#count/1","title":"khepri.count/1","type":"function"},{"doc":"Counts all tree nodes matching the given path pattern. This function accepts the following two forms: count(StoreId, PathPattern) . Calling it is the same as calling count(StoreId, PathPattern, \#{}) . count(PathPattern, Options) . Calling it is the same as calling count(StoreId, PathPattern, Options) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: count/3 .","ref":"khepri.html#count/2","title":"khepri.count/2","type":"function"},{"doc":"Counts all tree nodes matching the given path pattern. The PathPattern can be provided as a native path pattern (a list of tree node names and conditions) or as a string. See khepri_path:from_string/1 . The root node is not included in the count. Example: %% Query the tree node at `/:foo/:bar&#39;. { ok , 3 } = khepri : count ( StoreId , [ foo , ? KHEPRI_WILDCARD_STAR ] ) .","ref":"khepri.html#count/3","title":"khepri.count/3","type":"function"},{"doc":"","ref":"khepri.html#count!/1","title":"khepri.count!/1","type":"function"},{"doc":"","ref":"khepri.html#count!/2","title":"khepri.count!/2","type":"function"},{"doc":"","ref":"khepri.html#count!/3","title":"khepri.count!/3","type":"function"},{"doc":"Creates a tree node with the given payload. Calling this function is the same as calling create(StoreId, PathPattern, Data) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: create/3 , create/4 .","ref":"khepri.html#create/2","title":"khepri.create/2","type":"function"},{"doc":"Creates a tree node with the given payload. Calling this function is the same as calling create(StoreId, PathPattern, Data, \#{}) . See also: create/4 .","ref":"khepri.html#create/3","title":"khepri.create/3","type":"function"},{"doc":"Creates a tree node with the given payload. The behavior is the same as put/4 except that if the tree node already exists, an {error, ?khepri_error(mismatching_node, Info)} tuple is returned. Internally, the PathPattern is modified to include an #if_node_exists{exists = false} condition on its last component. See also: compare_and_swap/5 , put/4 , update/4 , khepri_adv:create/4 .","ref":"khepri.html#create/4","title":"khepri.create/4","type":"function"},{"doc":"","ref":"khepri.html#create!/2","title":"khepri.create!/2","type":"function"},{"doc":"","ref":"khepri.html#create!/3","title":"khepri.create!/3","type":"function"},{"doc":"","ref":"khepri.html#create!/4","title":"khepri.create!/4","type":"function"},{"doc":"Deletes the tree node pointed to by the given path pattern. Calling this function is the same as calling delete(StoreId, PathPattern) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: delete/2 , delete/3 .","ref":"khepri.html#delete/1","title":"khepri.delete/1","type":"function"},{"doc":"Deletes the tree node pointed to by the given path pattern. This function accepts the following two forms: delete(StoreId, PathPattern) . Calling it is the same as calling delete(StoreId, PathPattern, \#{}) . delete(PathPattern, Options) . Calling it is the same as calling delete(StoreId, PathPattern, Options) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: delete/3 .","ref":"khepri.html#delete/2","title":"khepri.delete/2","type":"function"},{"doc":"Deletes the tree node pointed to by the given path pattern. The PathPattern can be provided as a native path pattern (a list of tree node names and conditions) or as a string. See khepri_path:from_string/1 . The PathPattern must target a specific tree node. In other words, updating many nodes with the same payload is denied. That fact is checked before the tree node is looked up: so if a condition in the path could potentially match several nodes, an exception is raised, even though only one tree node would match at the time. If you want to delete multiple nodes at once, use delete_many/3 . Example: %% Delete the tree node at `/:foo/:bar&#39;. ok = khepri_adv : delete ( StoreId , [ foo , bar ] ) . See also: delete_many/3 , khepri_adv:delete/3 .","ref":"khepri.html#delete/3","title":"khepri.delete/3","type":"function"},{"doc":"","ref":"khepri.html#delete!/1","title":"khepri.delete!/1","type":"function"},{"doc":"","ref":"khepri.html#delete!/2","title":"khepri.delete!/2","type":"function"},{"doc":"","ref":"khepri.html#delete!/3","title":"khepri.delete!/3","type":"function"},{"doc":"Deletes all tree nodes matching the given path pattern. Calling this function is the same as calling delete_many(StoreId, PathPattern) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: delete_many/2 , delete_many/3 .","ref":"khepri.html#delete_many/1","title":"khepri.delete_many/1","type":"function"},{"doc":"Deletes all tree nodes matching the given path pattern. This function accepts the following two forms: delete_many(StoreId, PathPattern) . Calling it is the same as calling delete(StoreId, PathPattern, \#{}) . delete_many(PathPattern, Options) . Calling it is the same as calling delete(StoreId, PathPattern, Options) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: delete_many/3 .","ref":"khepri.html#delete_many/2","title":"khepri.delete_many/2","type":"function"},{"doc":"Deletes all tree nodes matching the given path pattern. The PathPattern can be provided as a native path pattern (a list of tree node names and conditions) or as a string. See khepri_path:from_string/1 . Example: %% Delete all nodes in the tree. ok = khepri_adv : delete_many ( StoreId , [ ? KHEPRI_WILDCARD_STAR ] ) . See also: delete/3 .","ref":"khepri.html#delete_many/3","title":"khepri.delete_many/3","type":"function"},{"doc":"","ref":"khepri.html#delete_many!/1","title":"khepri.delete_many!/1","type":"function"},{"doc":"","ref":"khepri.html#delete_many!/2","title":"khepri.delete_many!/2","type":"function"},{"doc":"","ref":"khepri.html#delete_many!/3","title":"khepri.delete_many!/3","type":"function"},{"doc":"Deletes the payload of all tree nodes matching the given path pattern. Calling this function is the same as calling delete_many_payloads(StoreId, PathPattern) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: delete_many_payloads/2 , delete_many_payloads/3 .","ref":"khepri.html#delete_many_payloads/1","title":"khepri.delete_many_payloads/1","type":"function"},{"doc":"Deletes the payload of all tree nodes matching the given path pattern. Calling this function is the same as calling delete_many_payloads(StoreId, PathPattern, \#{}) . See also: delete_many_payloads/3 .","ref":"khepri.html#delete_many_payloads/2","title":"khepri.delete_many_payloads/2","type":"function"},{"doc":"Deletes the payload of all tree nodes matching the given path pattern. In other words, the payload is set to khepri_payload:no_payload() . Otherwise, the behavior is that of put/4 . See also: delete_many/3 , put/4 , khepri_adv:delete_many_payloads/3 .","ref":"khepri.html#delete_many_payloads/3","title":"khepri.delete_many_payloads/3","type":"function"},{"doc":"","ref":"khepri.html#delete_many_payloads!/1","title":"khepri.delete_many_payloads!/1","type":"function"},{"doc":"","ref":"khepri.html#delete_many_payloads!/2","title":"khepri.delete_many_payloads!/2","type":"function"},{"doc":"","ref":"khepri.html#delete_many_payloads!/3","title":"khepri.delete_many_payloads!/3","type":"function"},{"doc":"Deletes the payload of the tree node pointed to by the given path pattern. Calling this function is the same as calling delete_payload(StoreId, PathPattern) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: delete_payload/2 , delete_payload/3 .","ref":"khepri.html#delete_payload/1","title":"khepri.delete_payload/1","type":"function"},{"doc":"Deletes the payload of the tree node pointed to by the given path pattern. Calling this function is the same as calling delete_payload(StoreId, PathPattern, \#{}) . See also: delete_payload/3 .","ref":"khepri.html#delete_payload/2","title":"khepri.delete_payload/2","type":"function"},{"doc":"Deletes the payload of the tree node pointed to by the given path pattern. In other words, the payload is set to khepri_payload:no_payload() . Otherwise, the behavior is that of put/4 . See also: put/4 , khepri_adv:delete_payload/3 .","ref":"khepri.html#delete_payload/3","title":"khepri.delete_payload/3","type":"function"},{"doc":"","ref":"khepri.html#delete_payload!/1","title":"khepri.delete_payload!/1","type":"function"},{"doc":"","ref":"khepri.html#delete_payload!/2","title":"khepri.delete_payload!/2","type":"function"},{"doc":"","ref":"khepri.html#delete_payload!/3","title":"khepri.delete_payload!/3","type":"function"},{"doc":"Indicates if the tree node pointed to by the given path exists or not. Calling this function is the same as calling exists(StoreId, PathPattern) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: exists/2 , exists/3 .","ref":"khepri.html#exists/1","title":"khepri.exists/1","type":"function"},{"doc":"Indicates if the tree node pointed to by the given path exists or not. This function accepts the following two forms: exists(StoreId, PathPattern) . Calling it is the same as calling exists(StoreId, PathPattern, \#{}) . exists(PathPattern, Options) . Calling it is the same as calling exists(StoreId, PathPattern, Options) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: exists/3 .","ref":"khepri.html#exists/2","title":"khepri.exists/2","type":"function"},{"doc":"Indicates if the tree node pointed to by the given path exists or not. The PathPattern can be provided as a native path pattern (a list of tree node names and conditions) or as a string. See khepri_path:from_string/1 . The PathPattern must target a specific tree node. In other words, updating many nodes with the same payload is denied. That fact is checked before the tree node is looked up: so if a condition in the path could potentially match several nodes, an exception is raised, even though only one tree node would match at the time. See also: get/3 .","ref":"khepri.html#exists/3","title":"khepri.exists/3","type":"function"},{"doc":"","ref":"khepri.html#exists!/1","title":"khepri.exists!/1","type":"function"},{"doc":"","ref":"khepri.html#exists!/2","title":"khepri.exists!/2","type":"function"},{"doc":"","ref":"khepri.html#exists!/3","title":"khepri.exists!/3","type":"function"},{"doc":"Returns the payload of the tree node pointed to by the given path pattern. Calling this function is the same as calling get(StoreId, PathPattern) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: get/2 , get/3 .","ref":"khepri.html#get/1","title":"khepri.get/1","type":"function"},{"doc":"Returns the payload of the tree node pointed to by the given path pattern. This function accepts the following two forms: get(StoreId, PathPattern) . Calling it is the same as calling get(StoreId, PathPattern, \#{}) . get(PathPattern, Options) . Calling it is the same as calling get(StoreId, PathPattern, Options) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: get/3 .","ref":"khepri.html#get/2","title":"khepri.get/2","type":"function"},{"doc":"Returns the payload of the tree node pointed to by the given path pattern. The PathPattern can be provided as a native path pattern (a list of tree node names and conditions) or as a string. See khepri_path:from_string/1 . The PathPattern must target a specific tree node. In other words, updating many nodes with the same payload is denied. That fact is checked before the tree node is looked up: so if a condition in the path could potentially match several nodes, an exception is raised, even though only one tree node would match at the time. The returned {ok, Payload} tuple contains the payload of the targeted tree node, or {ok, undefined} if the tree node had no payload. Example: query a tree node which holds the atom value %% Query the tree node at `/:foo/:bar&#39;. { ok , value } = khepri : get ( StoreId , [ foo , bar ] ) . Example: query an existing tree node with no payload %% Query the tree node at `/:no_payload&#39;. { ok , undefined } = khepri : get ( StoreId , [ no_payload ] ) . Example: query a non-existent tree node %% Query the tree node at `/:non_existent&#39;. { error , ? khepri_error ( node_not_found , _ ) } = khepri : get ( StoreId , [ non_existent ] ) . See also: get_many/3 , get_or/3 , khepri_adv:get/3 .","ref":"khepri.html#get/3","title":"khepri.get/3","type":"function"},{"doc":"","ref":"khepri.html#get!/1","title":"khepri.get!/1","type":"function"},{"doc":"","ref":"khepri.html#get!/2","title":"khepri.get!/2","type":"function"},{"doc":"","ref":"khepri.html#get!/3","title":"khepri.get!/3","type":"function"},{"doc":"Returns payloads of all the tree nodes matching the given path pattern. Calling this function is the same as calling get_many(StoreId, PathPattern) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: get_many/2 , get_many/3 .","ref":"khepri.html#get_many/1","title":"khepri.get_many/1","type":"function"},{"doc":"Returns payloads of all the tree nodes matching the given path pattern. This function accepts the following two forms: get_many(StoreId, PathPattern) . Calling it is the same as calling get_many(StoreId, PathPattern, \#{}) . get_many(PathPattern, Options) . Calling it is the same as calling get_many(StoreId, PathPattern, Options) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: get_many/3 .","ref":"khepri.html#get_many/2","title":"khepri.get_many/2","type":"function"},{"doc":"Returns payloads of all the tree nodes matching the given path pattern. Calling this function is the same as calling get_many_or(StoreId, PathPattern, undefined, Options) . The PathPattern can be provided as a native path pattern (a list of tree node names and conditions) or as a string. See khepri_path:from_string/1 . The returned {ok, PayloadsMap} tuple contains a map where keys correspond to the path to a tree node matching the path pattern. Each key then points to the payload of that matching tree node, or Default if the tree node had no payload. Example: query all nodes in the tree %% Get all nodes in the tree. The tree is: %% &lt;root&gt; %% `-- foo %% `-- bar = value { ok , \#{ [ foo ] := undefined , [ foo , bar ] := value } } = khepri : get_many ( StoreId , [ ? KHEPRI_WILDCARD_STAR_STAR ] ) . See also: get/3 , get_many_or/4 , khepri_adv:get_many/3 .","ref":"khepri.html#get_many/3","title":"khepri.get_many/3","type":"function"},{"doc":"","ref":"khepri.html#get_many!/1","title":"khepri.get_many!/1","type":"function"},{"doc":"","ref":"khepri.html#get_many!/2","title":"khepri.get_many!/2","type":"function"},{"doc":"","ref":"khepri.html#get_many!/3","title":"khepri.get_many!/3","type":"function"},{"doc":"Returns payloads of all the tree nodes matching the given path pattern, or a default payload. Calling this function is the same as calling get_many_or(StoreId, PathPattern, Default) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: get_many_or/3 , get_many_or/4 .","ref":"khepri.html#get_many_or/2","title":"khepri.get_many_or/2","type":"function"},{"doc":"Returns payloads of all the tree nodes matching the given path pattern, or a default payload. This function accepts the following two forms: get_many_or(StoreId, PathPattern, Default) . Calling it is the same as calling get_many_or(StoreId, PathPattern, Default, \#{}) . get_many_or(PathPattern, Default, Options) . Calling it is the same as calling get_many_or(StoreId, PathPattern, Default, Options) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: get_many_or/4 .","ref":"khepri.html#get_many_or/3","title":"khepri.get_many_or/3","type":"function"},{"doc":"Returns payloads of all the tree nodes matching the given path pattern, or a default payload. The PathPattern can be provided as a native path pattern (a list of tree node names and conditions) or as a string. See khepri_path:from_string/1 . The returned {ok, PayloadsMap} tuple contains a map where keys correspond to the path to a tree node matching the path pattern. Each key then points to the payload of that matching tree node, or Default if the tree node had no payload. Example: query all nodes in the tree %% Get all nodes in the tree. The tree is: %% &lt;root&gt; %% `-- foo %% `-- bar = value { ok , \#{ [ foo ] := default , [ foo , bar ] := value } } = khepri : get_many_or ( StoreId , [ ? KHEPRI_WILDCARD_STAR_STAR ] , default ) . See also: get_many/3 , get_or/4 , khepri_adv:get_many/3 .","ref":"khepri.html#get_many_or/4","title":"khepri.get_many_or/4","type":"function"},{"doc":"","ref":"khepri.html#get_many_or!/2","title":"khepri.get_many_or!/2","type":"function"},{"doc":"","ref":"khepri.html#get_many_or!/3","title":"khepri.get_many_or!/3","type":"function"},{"doc":"","ref":"khepri.html#get_many_or!/4","title":"khepri.get_many_or!/4","type":"function"},{"doc":"Returns the payload of the tree node pointed to by the given path pattern, or a default value. Calling this function is the same as calling get_or(StoreId, PathPattern, Default) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: get_or/3 , get_or/4 .","ref":"khepri.html#get_or/2","title":"khepri.get_or/2","type":"function"},{"doc":"Returns the payload of the tree node pointed to by the given path pattern, or a default value. This function accepts the following two forms: get_or(StoreId, PathPattern, Default) . Calling it is the same as calling get_or(StoreId, PathPattern, Default, \#{}) . get_or(PathPattern, Default, Options) . Calling it is the same as calling get_or(StoreId, PathPattern, Default, Options) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: get_or/4 .","ref":"khepri.html#get_or/3","title":"khepri.get_or/3","type":"function"},{"doc":"Returns the payload of the tree node pointed to by the given path pattern, or a default value. The PathPattern can be provided as a native path pattern (a list of tree node names and conditions) or as a string. See khepri_path:from_string/1 . The PathPattern must target a specific tree node. In other words, updating many nodes with the same payload is denied. That fact is checked before the tree node is looked up: so if a condition in the path could potentially match several nodes, an exception is raised, even though only one tree node would match at the time. The returned {ok, Payload} tuple contains the payload of the targeted tree node, or {ok, Default} if the tree node had no payload or was not found. Example: query a tree node which holds the atom value %% Query the tree node at `/:foo/:bar&#39;. { ok , value } = khepri : get_or ( StoreId , [ foo , bar ] , default ) . Example: query an existing tree node with no payload %% Query the tree node at `/:no_payload&#39;. { ok , default } = khepri : get_or ( StoreId , [ no_payload ] , default ) . Example: query a non-existent tree node %% Query the tree node at `/:non_existent&#39;. { ok , default } = khepri : get_or ( StoreId , [ non_existent ] , default ) . See also: get/3 , get_many_or/4 , khepri_adv:get/3 .","ref":"khepri.html#get_or/4","title":"khepri.get_or/4","type":"function"},{"doc":"","ref":"khepri.html#get_or!/2","title":"khepri.get_or!/2","type":"function"},{"doc":"","ref":"khepri.html#get_or!/3","title":"khepri.get_or!/3","type":"function"},{"doc":"","ref":"khepri.html#get_or!/4","title":"khepri.get_or!/4","type":"function"},{"doc":"Returns the list of running stores. See also: khepri_cluster:get_store_ids/0 .","ref":"khepri.html#get_store_ids/0","title":"khepri.get_store_ids/0","type":"function"},{"doc":"Indicates if the tree node pointed to by the given path has data or not. Calling this function is the same as calling has_data(StoreId, PathPattern) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: has_data/2 , has_data/3 .","ref":"khepri.html#has_data/1","title":"khepri.has_data/1","type":"function"},{"doc":"Indicates if the tree node pointed to by the given path has data or not. This function accepts the following two forms: has_data(StoreId, PathPattern) . Calling it is the same as calling has_data(StoreId, PathPattern, \#{}) . has_data(PathPattern, Options) . Calling it is the same as calling has_data(StoreId, PathPattern, Options) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: has_data/3 .","ref":"khepri.html#has_data/2","title":"khepri.has_data/2","type":"function"},{"doc":"Indicates if the tree node pointed to by the given path has data or not. The PathPattern can be provided as a native path pattern (a list of tree node names and conditions) or as a string. See khepri_path:from_string/1 . The PathPattern must target a specific tree node. In other words, updating many nodes with the same payload is denied. That fact is checked before the tree node is looked up: so if a condition in the path could potentially match several nodes, an exception is raised, even though only one tree node would match at the time. See also: get/3 .","ref":"khepri.html#has_data/3","title":"khepri.has_data/3","type":"function"},{"doc":"","ref":"khepri.html#has_data!/1","title":"khepri.has_data!/1","type":"function"},{"doc":"","ref":"khepri.html#has_data!/2","title":"khepri.has_data!/2","type":"function"},{"doc":"","ref":"khepri.html#has_data!/3","title":"khepri.has_data!/3","type":"function"},{"doc":"Lists the running stores on stdout .","ref":"khepri.html#info/0","title":"khepri.info/0","type":"function"},{"doc":"Lists the content of specified store on stdout .","ref":"khepri.html#info/1","title":"khepri.info/1","type":"function"},{"doc":"Lists the content of specified store on stdout .","ref":"khepri.html#info/2","title":"khepri.info/2","type":"function"},{"doc":"Indicates if the tree node pointed to by the given path holds a stored procedure or not. Calling this function is the same as calling is_sproc(StoreId, PathPattern) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: is_sproc/2 , is_sproc/3 .","ref":"khepri.html#is_sproc/1","title":"khepri.is_sproc/1","type":"function"},{"doc":"Indicates if the tree node pointed to by the given path holds a stored procedure or not. This function accepts the following two forms: is_sproc(StoreId, PathPattern) . Calling it is the same as calling is_sproc(StoreId, PathPattern, \#{}) . is_sproc(PathPattern, Options) . Calling it is the same as calling is_sproc(StoreId, PathPattern, Options) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: is_sproc/3 .","ref":"khepri.html#is_sproc/2","title":"khepri.is_sproc/2","type":"function"},{"doc":"Indicates if the tree node pointed to by the given path holds a stored procedure or not. The PathPattern can be provided as a native path pattern (a list of tree node names and conditions) or as a string. See khepri_path:from_string/1 . The PathPattern must target a specific tree node. In other words, updating many nodes with the same payload is denied. That fact is checked before the tree node is looked up: so if a condition in the path could potentially match several nodes, an exception is raised, even though only one tree node would match at the time. See also: get/3 .","ref":"khepri.html#is_sproc/3","title":"khepri.is_sproc/3","type":"function"},{"doc":"","ref":"khepri.html#is_sproc!/1","title":"khepri.is_sproc!/1","type":"function"},{"doc":"","ref":"khepri.html#is_sproc!/2","title":"khepri.is_sproc!/2","type":"function"},{"doc":"","ref":"khepri.html#is_sproc!/3","title":"khepri.is_sproc!/3","type":"function"},{"doc":"Sets the payload of the tree node pointed to by the given path pattern. Calling this function is the same as calling put(StoreId, PathPattern, Data) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: put/3 , put/4 .","ref":"khepri.html#put/2","title":"khepri.put/2","type":"function"},{"doc":"Sets the payload of the tree node pointed to by the given path pattern. Calling this function is the same as calling put(StoreId, PathPattern, Data, \#{}) . See also: put/4 .","ref":"khepri.html#put/3","title":"khepri.put/3","type":"function"},{"doc":"Sets the payload of the tree node pointed to by the given path pattern. The PathPattern can be provided as a native path pattern (a list of tree node names and conditions) or as a string. See khepri_path:from_string/1 . The PathPattern must target a specific tree node. In other words, updating many nodes with the same payload is denied. That fact is checked before the tree node is looked up: so if a condition in the path could potentially match several nodes, an exception is raised, even though only one tree node would match at the time. When using a simple path (i.e. without conditions), if the targeted tree node does not exist, it is created using the given payload. If the targeted tree node exists, it is updated with the given payload and its payload version is increased by one. Missing parent nodes are created on the way. When using a path pattern, the behavior is the same. However if a condition in the path pattern is not met, an error is returned and the tree structure is not modified. The payload must be one of the following form: An explicit absence of payload ( khepri_payload:no_payload() ), using the marker returned by khepri_payload:none/0 , meaning there will be no payload attached to the tree node and the existing payload will be discarded if any An anonymous function; it will be considered a stored procedure and will be wrapped in a khepri_payload:sproc() record Any other term; it will be wrapped in a khepri_payload:data() record It is possible to wrap the payload in its internal structure explicitly using the khepri_payload module directly. The Options map may specify command-level options; see khepri:command_options() , khepri:tree_options() and khepri:put_options() . When doing an asynchronous update, the wait_for_async_ret/1 function can be used to receive the message from Ra. Example: %% Insert a tree node at `/:foo/:bar&#39;, overwriting the previous value. ok = khepri_adv : put ( StoreId , [ foo , bar ] , new_value ) . See also: compare_and_swap/5 , create/4 , put_many/4 , update/4 , khepri_adv:put/4 .","ref":"khepri.html#put/4","title":"khepri.put/4","type":"function"},{"doc":"","ref":"khepri.html#put!/2","title":"khepri.put!/2","type":"function"},{"doc":"","ref":"khepri.html#put!/3","title":"khepri.put!/3","type":"function"},{"doc":"","ref":"khepri.html#put!/4","title":"khepri.put!/4","type":"function"},{"doc":"Sets the payload of all the tree nodes matching the given path pattern. Calling this function is the same as calling put_many(StoreId, PathPattern, Data) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: put_many/3 , put_many/4 .","ref":"khepri.html#put_many/2","title":"khepri.put_many/2","type":"function"},{"doc":"Sets the payload of all the tree nodes matching the given path pattern. Calling this function is the same as calling put_many(StoreId, PathPattern, Data, \#{}) . See also: put_many/4 .","ref":"khepri.html#put_many/3","title":"khepri.put_many/3","type":"function"},{"doc":"Sets the payload of all the tree nodes matching the given path pattern. The PathPattern can be provided as a native path pattern (a list of tree node names and conditions) or as a string. See khepri_path:from_string/1 . When using a simple path (i.e. without conditions), if the targeted tree node does not exist, it is created using the given payload. If the targeted tree node exists, it is updated with the given payload and its payload version is increased by one. Missing parent nodes are created on the way. When using a path pattern, the behavior is the same. However if a condition in the path pattern is not met, an error is returned and the tree structure is not modified. The payload must be one of the following form: An explicit absence of payload ( khepri_payload:no_payload() ), using the marker returned by khepri_payload:none/0 , meaning there will be no payload attached to the tree node and the existing payload will be discarded if any An anonymous function; it will be considered a stored procedure and will be wrapped in a khepri_payload:sproc() record Any other term; it will be wrapped in a khepri_payload:data() record It is possible to wrap the payload in its internal structure explicitly using the khepri_payload module directly. The Options map may specify command-level options; see khepri:command_options() , khepri:tree_options() and khepri:put_options() . When doing an asynchronous update, the wait_for_async_ret/1 function can be used to receive the message from Ra. Example: %% Insert a tree node at `/:foo/:bar&#39;, overwriting the previous value. ok = khepri_adv : put ( StoreId , [ foo , bar ] , new_value ) . See also: put/4 , khepri_adv:put_many/4 .","ref":"khepri.html#put_many/4","title":"khepri.put_many/4","type":"function"},{"doc":"","ref":"khepri.html#put_many!/2","title":"khepri.put_many!/2","type":"function"},{"doc":"","ref":"khepri.html#put_many!/3","title":"khepri.put_many!/3","type":"function"},{"doc":"","ref":"khepri.html#put_many!/4","title":"khepri.put_many!/4","type":"function"},{"doc":"Registers a trigger. Calling this function is the same as calling register_trigger(StoreId, TriggerId, EventFilter, StoredProcPath) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: register_trigger/4 .","ref":"khepri.html#register_trigger/3","title":"khepri.register_trigger/3","type":"function"},{"doc":"Registers a trigger. This function accepts the following two forms: register_trigger(StoreId, TriggerId, EventFilter, StoredProcPath) . Calling it is the same as calling register_trigger(StoreId, TriggerId, EventFilter, StoredProcPath, \#{}) . register_trigger(TriggerId, EventFilter, StoredProcPath, Options) . Calling it is the same as calling register_trigger(StoreId, TriggerId, EventFilter, StoredProcPath, Options) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: register_trigger/5 .","ref":"khepri.html#register_trigger/4","title":"khepri.register_trigger/4","type":"function"},{"doc":"Registers a trigger. A trigger is based on an event filter. It associates an event with a stored procedure. When an event matching the event filter is emitted, the stored procedure is executed. The following event filters are documented by khepri_evf:event_filter() . Here are examples of event filters: %% An event filter can be explicitly created using the `khepri_evf&#39; %% module. This is possible to specify properties at the same time. EventFilter = khepri_evf : tree ( [ stock , wood , &lt;&lt; &quot;oak&quot; &gt;&gt; ] , %% Required \#{ on_actions =&gt; [ delete ] , %% Optional priority =&gt; 10 } ) . %% Optional %% For ease of use, some terms can be automatically converted to an event %% filter. In this example, a Unix-like path can be used as a tree event %% filter. EventFilter = &quot;/:stock/:wood/oak&quot; . The stored procedure is expected to accept a single argument. This argument is a map containing the event properties. Here is an example: my_stored_procedure ( Props ) -&gt; \#{ path := Path } , on_action =&gt; Action } = Props . The stored procedure is executed on the leader's Erlang node. It is guaranteed to run at least once. It could be executed multiple times if the Ra leader changes, therefore the stored procedure must be idempotent.","ref":"khepri.html#register_trigger/5","title":"khepri.register_trigger/5","type":"function"},{"doc":"Resets the store on this Erlang node. See also: khepri_cluster:reset/0 .","ref":"khepri.html#reset/0","title":"khepri.reset/0","type":"function"},{"doc":"Resets the store on this Erlang node. See also: khepri_cluster:reset/1 .","ref":"khepri.html#reset/1","title":"khepri.reset/1","type":"function"},{"doc":"Resets the store on this Erlang node. See also: khepri_cluster:reset/2 .","ref":"khepri.html#reset/2","title":"khepri.reset/2","type":"function"},{"doc":"Runs the stored procedure pointed to by the given path and returns the result. Calling this function is the same as calling run_sproc(StoreId, PathPattern, Args) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: run_sproc/3 , run_sproc/4 .","ref":"khepri.html#run_sproc/2","title":"khepri.run_sproc/2","type":"function"},{"doc":"Runs the stored procedure pointed to by the given path and returns the result. This function accepts the following two forms: run_sproc(StoreId, PathPattern, Args) . Calling it is the same as calling run_sproc(StoreId, PathPattern, Args, \#{}) . run_sproc(PathPattern, Args, Options) . Calling it is the same as calling run_sproc(StoreId, PathPattern, Args, Options) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: run_sproc/4 .","ref":"khepri.html#run_sproc/3","title":"khepri.run_sproc/3","type":"function"},{"doc":"Runs the stored procedure pointed to by the given path and returns the result. The PathPattern can be provided as a native path pattern (a list of tree node names and conditions) or as a string. See khepri_path:from_string/1 . The PathPattern must target a specific tree node. In other words, updating many nodes with the same payload is denied. That fact is checked before the tree node is looked up: so if a condition in the path could potentially match several nodes, an exception is raised, even though only one tree node would match at the time. The length of the Args list must match the number of arguments expected by the stored procedure. See also: is_sproc/3 .","ref":"khepri.html#run_sproc/4","title":"khepri.run_sproc/4","type":"function"},{"doc":"Starts a store. See also: khepri_cluster:start/0 .","ref":"khepri.html#start/0","title":"khepri.start/0","type":"function"},{"doc":"Starts a store. See also: khepri_cluster:start/1 .","ref":"khepri.html#start/1","title":"khepri.start/1","type":"function"},{"doc":"Starts a store. See also: khepri_cluster:start/2 .","ref":"khepri.html#start/2","title":"khepri.start/2","type":"function"},{"doc":"Starts a store. See also: khepri_cluster:start/3 .","ref":"khepri.html#start/3","title":"khepri.start/3","type":"function"},{"doc":"Stops a store. See also: khepri_cluster:stop/0 .","ref":"khepri.html#stop/0","title":"khepri.stop/0","type":"function"},{"doc":"Stops a store. See also: khepri_cluster:stop/1 .","ref":"khepri.html#stop/1","title":"khepri.stop/1","type":"function"},{"doc":"Runs a transaction and returns its result. Calling this function is the same as calling transaction(StoreId, Fun) with the default store ID. See also: transaction/2 .","ref":"khepri.html#transaction/1","title":"khepri.transaction/1","type":"function"},{"doc":"Runs a transaction and returns its result. This function accepts the following two forms: transaction(StoreId, Fun) . Calling it is the same as calling transaction(StoreId, Fun, \#{}) . transaction(Fun, Options) . Calling it is the same as calling transaction(StoreId, Fun, Options) with the default store ID. See also: transaction/3 .","ref":"khepri.html#transaction/2","title":"khepri.transaction/2","type":"function"},{"doc":"Runs a transaction and returns its result. This function accepts the following three forms: transaction(StoreId, PathPattern, ReadWrite) . Calling it is the same as calling transaction(StoreId, PathPattern, ReadWrite, \#{}) . transaction(StoreId, PathPattern, Options) . Calling it is the same as calling transaction(StoreId, PathPattern, auto, Options) . transaction(PathPattern, ReadWrite, Options) . Calling it is the same as calling transaction(StoreId, PathPattern, ReadWrite, Options) with the default store ID. See also: transaction/4 .","ref":"khepri.html#transaction/3","title":"khepri.transaction/3","type":"function"},{"doc":"Runs a transaction and returns its result. Fun is an arbitrary anonymous function which takes no arguments. The ReadWrite flag determines what the anonymous function is allowed to do and in which context it runs: If ReadWrite is ro , Fun can do whatever it wants, except modify the content of the store. In other words, uses of khepri_tx:put/2 or khepri_tx:delete/1 are forbidden and will abort the function. Fun is executed from a process on the leader Ra member. If ReadWrite is rw , Fun can use the khepri_tx transaction API as well as any calls to other modules as long as those functions or what they do is permitted. See khepri_tx for more details. If Fun does or calls something forbidden, the transaction will be aborted. Fun is executed in the context of the state machine process on each Ra members. If ReadWrite is auto , Fun is analyzed to determine if it calls khepri_tx:put/2 or khepri_tx:delete/1 , or uses any denied operations for a read/write transaction. If it does, this is the same as setting ReadWrite to true. Otherwise, this is the equivalent of setting ReadWrite to false. Options is relevant for both read-only and read-write transactions (including audetected ones). However note that both types expect different options. The result of Fun can be any term. That result is returned in an {ok, Result} tuple if the transaction is synchronous. The result is sent by message if the transaction is asynchronous and a correlation ID was specified.","ref":"khepri.html#transaction/4","title":"khepri.transaction/4","type":"function"},{"doc":"Updates an existing tree node with the given payload. Calling this function is the same as calling update(StoreId, PathPattern, Data) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: update/3 , update/4 .","ref":"khepri.html#update/2","title":"khepri.update/2","type":"function"},{"doc":"Updates an existing tree node with the given payload. Calling this function is the same as calling update(StoreId, PathPattern, Data, \#{}) . See also: update/4 .","ref":"khepri.html#update/3","title":"khepri.update/3","type":"function"},{"doc":"Updates an existing tree node with the given payload. The behavior is the same as put/4 except that if the tree node already exists, an {error, ?khepri_error(mismatching_node, Info)} tuple is returned. Internally, the PathPattern is modified to include an #if_node_exists{exists = true} condition on its last component. See also: compare_and_swap/5 , create/4 , put/4 , khepri_adv:update/4 .","ref":"khepri.html#update/4","title":"khepri.update/4","type":"function"},{"doc":"","ref":"khepri.html#update!/2","title":"khepri.update!/2","type":"function"},{"doc":"","ref":"khepri.html#update!/3","title":"khepri.update!/3","type":"function"},{"doc":"","ref":"khepri.html#update!/4","title":"khepri.update!/4","type":"function"},{"doc":"Waits for an asynchronous call. Calling this function is the same as calling wait_for_async_ret(Correlation) with the default timeout (see khepri_app:get_default_timeout/0 ). See also: wait_for_async_ret/2 .","ref":"khepri.html#wait_for_async_ret/1","title":"khepri.wait_for_async_ret/1","type":"function"},{"doc":"Waits for an asynchronous call. This function waits maximum Timeout milliseconds (or infinity ) for the result of a previous call where the async option was set with a correlation ID. That correlation ID must be passed to this function. See also: wait_for_async_ret/2 .","ref":"khepri.html#wait_for_async_ret/2","title":"khepri.wait_for_async_ret/2","type":"function"},{"doc":"Option to indicate if the command should be synchronous or asynchronous. Values are: true to perform an asynchronous low-priority command without a correlation ID. false to perform a synchronous command. A correlation ID to perform an asynchronous low-priority command with that correlation ID. A priority to perform an asynchronous command with the specified priority but without a correlation ID. A combination of a correlation ID and a priority to perform an asynchronous command with the specified parameters.","ref":"khepri.html#t:async_option/0","title":"khepri.async_option/0","type":"type"},{"doc":"Number of direct child nodes under a tree node.","ref":"khepri.html#t:child_list_length/0","title":"khepri.child_list_length/0","type":"type"},{"doc":"Number of changes made to the list of child nodes of a tree node (child nodes added or removed). The child list version starts at 1 when a tree node is created. It is increased by 1 each time a child is added or removed. Changes made to existing nodes are not reflected in this version.","ref":"khepri.html#t:child_list_version/0","title":"khepri.child_list_version/0","type":"type"},{"doc":"Options used in commands. Commands are put/5 , delete/3 and read-write transaction/4 . timeout is passed to Ra command processing function. async indicates the synchronous or asynchronous nature of the command; see async_option() .","ref":"khepri.html#t:command_options/0","title":"khepri.command_options/0","type":"type"},{"doc":"Data stored in a tree node's payload.","ref":"khepri.html#t:data/0","title":"khepri.data/0","type":"type"},{"doc":"The error tuple returned by a function after a failure.","ref":"khepri.html#t:error/0","title":"khepri.error/0","type":"type"},{"doc":"Return value of a failed command or query.","ref":"khepri.html#t:error/1","title":"khepri.error/1","type":"type"},{"doc":"Option to indicate where to put the cursor between freshness of the returned data and low latency of queries. Values are: consistent means that a &quot;consistent query&quot; will be used in Ra. It will return the most up-to-date piece of data the cluster agreed on. Note that it could block and eventually time out if there is no quorum in the Ra cluster. compromise performs &quot;leader queries&quot; most of the time to reduce latency, but uses &quot;consistent queries&quot; every 10 seconds to verify that the cluster is healthy on a regular basis. It should be faster but may block and time out like consistent and still return slightly out-of-date data. low_latency means that &quot;local queries&quot; are used exclusively. They are the fastest and have the lowest latency. However, the returned data is whatever the local Ra server has. It could be out-of-date if it has troubles keeping up with the Ra cluster. The chance of blocking and timing out is very small.","ref":"khepri.html#t:favor_option/0","title":"khepri.favor_option/0","type":"type"},{"doc":"The return value of query functions in the khepri module that work on a many nodes. undefined is returned if a tree node has no payload attached to it.","ref":"khepri.html#t:many_payloads_ret/0","title":"khepri.many_payloads_ret/0","type":"type"},{"doc":"The return value of query functions in the khepri module that work on many nodes. Default is the value to return if a tree node has no payload attached to it.","ref":"khepri.html#t:many_payloads_ret/1","title":"khepri.many_payloads_ret/1","type":"type"},{"doc":"The return value of update functions in the khepri module.","ref":"khepri.html#t:minimal_ret/0","title":"khepri.minimal_ret/0","type":"type"},{"doc":"Structure used to return properties, payload and child nodes for a specific tree node. The payload in data or sproc is only returned if the tree node carries something. If that key is missing from the returned properties map, it means the tree node has no payload. By default, the payload (if any) and its version are returned by functions exposed by khepri_adv . The list of returned properties can be configured using the props_to_return option (see tree_options() ).","ref":"khepri.html#t:node_props/0","title":"khepri.node_props/0","type":"type"},{"doc":"The result of a function after a successful call, wrapped in an &quot;ok&quot; tuple.","ref":"khepri.html#t:ok/1","title":"khepri.ok/1","type":"type"},{"doc":"The return value of query functions in the khepri module that work on a single tree node. undefined is returned if a tree node has no payload attached to it.","ref":"khepri.html#t:payload_ret/0","title":"khepri.payload_ret/0","type":"type"},{"doc":"The return value of query functions in the khepri module that work on a single tree node. Default is the value to return if a tree node has no payload attached to it.","ref":"khepri.html#t:payload_ret/1","title":"khepri.payload_ret/1","type":"type"},{"doc":"Number of changes made to the payload of a tree node. The payload version starts at 1 when a tree node is created. It is increased by 1 each time the payload is added, modified or removed.","ref":"khepri.html#t:payload_version/0","title":"khepri.payload_version/0","type":"type"},{"doc":"Options specific to updates. keep_while allows to define keep-while conditions on the created/updated tree node.","ref":"khepri.html#t:put_options/0","title":"khepri.put_options/0","type":"type"},{"doc":"Options used in queries. timeout is passed to Ra query processing function. favor indicates where to put the cursor between freshness of the returned data and low latency of queries; see favor_option() .","ref":"khepri.html#t:query_options/0","title":"khepri.query_options/0","type":"type"},{"doc":"ID of a Khepri store. This is the same as the Ra cluster name hosting the Khepri store.","ref":"khepri.html#t:store_id/0","title":"khepri.store_id/0","type":"type"},{"doc":"Options used during tree traversal. expect_specific_node indicates if the path is expected to point to a specific tree node or could match many nodes. props_to_return indicates the list of properties to include in the returned tree node properties map. The default is [payload, payload_version] . Note that payload and has_payload are a bit special: the actually returned properties will be data / sproc and has_data / is_sproc respectively. include_root_props indicates if root properties and payload should be returned as well.","ref":"khepri.html#t:tree_options/0","title":"khepri.tree_options/0","type":"type"},{"doc":"An ID to identify a registered trigger.","ref":"khepri.html#t:trigger_id/0","title":"khepri.trigger_id/0","type":"type"},{"doc":"","ref":"khepri.html#t:unwrapped_many_payloads_ret/0","title":"khepri.unwrapped_many_payloads_ret/0","type":"type"},{"doc":"","ref":"khepri.html#t:unwrapped_many_payloads_ret/1","title":"khepri.unwrapped_many_payloads_ret/1","type":"type"},{"doc":"","ref":"khepri.html#t:unwrapped_minimal_ret/0","title":"khepri.unwrapped_minimal_ret/0","type":"type"},{"doc":"","ref":"khepri.html#t:unwrapped_payload_ret/0","title":"khepri.unwrapped_payload_ret/0","type":"type"},{"doc":"","ref":"khepri.html#t:unwrapped_payload_ret/1","title":"khepri.unwrapped_payload_ret/1","type":"type"},{"doc":"Khepri database advanced API. This module exposes variants of the functions in khepri which return more detailed return values for advanced use cases. Here are some examples of what can be achieved with this module: Distinguish a tree node with the undefined atom as its payload, from a tree node with no payload, from a non-existing tree node. Know the payload version after a call to the functions based on put/5 which can be useful to perform transactional operations without using khepri:transaction/4 . Functions provided by khepri are implemented on top of this module and simplify the return value for the more common use cases.","ref":"khepri_adv.html","title":"khepri_adv","type":"module"},{"doc":"Updates an existing tree node with the given payload only if its data matches the given pattern. Calling this function is the same as calling compare_and_swap(StoreId, PathPattern, DataPattern, Data) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: compare_and_swap/4 , compare_and_swap/5 .","ref":"khepri_adv.html#compare_and_swap/3","title":"khepri_adv.compare_and_swap/3","type":"function"},{"doc":"Updates an existing tree node with the given payload only if its data matches the given pattern. Calling this function is the same as calling compare_and_swap(StoreId, PathPattern, DataPattern, Data, \#{}) . See also: compare_and_swap/5 .","ref":"khepri_adv.html#compare_and_swap/4","title":"khepri_adv.compare_and_swap/4","type":"function"},{"doc":"Updates an existing tree node with the given payload only if its data matches the given pattern. The behavior is the same as put/4 except that if the tree node already exists, an {error, ?khepri_error(mismatching_node, Info)} tuple is returned. Internally, the PathPattern is modified to include an #if_data_matches{pattern = DataPattern} condition on its last component. See also: put/4 , khepri:compare_and_swap/5 .","ref":"khepri_adv.html#compare_and_swap/5","title":"khepri_adv.compare_and_swap/5","type":"function"},{"doc":"Creates a tree node with the given payload. Calling this function is the same as calling create(StoreId, PathPattern, Data) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: create/3 , create/4 .","ref":"khepri_adv.html#create/2","title":"khepri_adv.create/2","type":"function"},{"doc":"Creates a tree node with the given payload. Calling this function is the same as calling create(StoreId, PathPattern, Data, \#{}) . See also: create/4 .","ref":"khepri_adv.html#create/3","title":"khepri_adv.create/3","type":"function"},{"doc":"Creates a tree node with the given payload. The behavior is the same as put/4 except that if the tree node already exists, an {error, ?khepri_error(mismatching_node, Info)} tuple is returned. Internally, the PathPattern is modified to include an #if_node_exists{exists = false} condition on its last component. See also: put/4 , update/4 , khepri:create/4 .","ref":"khepri_adv.html#create/4","title":"khepri_adv.create/4","type":"function"},{"doc":"Deletes the tree node pointed to by the given path pattern. Calling this function is the same as calling delete(StoreId, PathPattern) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: delete/2 , delete/3 .","ref":"khepri_adv.html#delete/1","title":"khepri_adv.delete/1","type":"function"},{"doc":"Deletes the tree node pointed to by the given path pattern. This function accepts the following two forms: delete(StoreId, PathPattern) . Calling it is the same as calling delete(StoreId, PathPattern, \#{}) . delete(PathPattern, Options) . Calling it is the same as calling delete(StoreId, PathPattern, Options) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: delete/3 .","ref":"khepri_adv.html#delete/2","title":"khepri_adv.delete/2","type":"function"},{"doc":"Deletes the tree node pointed to by the given path pattern. The PathPattern can be provided as a native path pattern (a list of tree node names and conditions) or as a string. See khepri_path:from_string/1 . The PathPattern must target a specific tree node. In other words, updating many nodes with the same payload is denied. That fact is checked before the tree node is looked up: so if a condition in the path could potentially match several nodes, an exception is raised, even though only one tree node would match at the time. If you want to delete multiple nodes at once, use delete_many/3 . The returned {ok, NodeProps} tuple contains a map with the properties and payload (if any) of the targeted tree node as they were before the delete. If the targeted tree node didn't exist, NodeProps will be an empty map. When doing an asynchronous update, the wait_for_async_ret/1 function can be used to receive the message from Ra. Example: %% Delete the tree node at `/:foo/:bar&#39;. { ok , \#{ data := value , payload_version := 1 } } = khepri_adv : delete ( StoreId , [ foo , bar ] ) . See also: delete_many/3 , khepri:delete/3 .","ref":"khepri_adv.html#delete/3","title":"khepri_adv.delete/3","type":"function"},{"doc":"Deletes all tree nodes matching the given path pattern. Calling this function is the same as calling delete_many(StoreId, PathPattern) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: delete_many/2 , delete_many/3 .","ref":"khepri_adv.html#delete_many/1","title":"khepri_adv.delete_many/1","type":"function"},{"doc":"Deletes all tree nodes matching the given path pattern. This function accepts the following two forms: delete_many(StoreId, PathPattern) . Calling it is the same as calling delete(StoreId, PathPattern, \#{}) . delete_many(PathPattern, Options) . Calling it is the same as calling delete(StoreId, PathPattern, Options) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: delete_many/3 .","ref":"khepri_adv.html#delete_many/2","title":"khepri_adv.delete_many/2","type":"function"},{"doc":"Deletes all tree nodes matching the given path pattern. The PathPattern can be provided as a native path pattern (a list of tree node names and conditions) or as a string. See khepri_path:from_string/1 . The returned {ok, NodePropsMap} tuple contains a map where keys correspond to the path to a deleted tree node. Each key then points to a map containing the properties and payload (if any) of that deleted tree node as they were before the delete. When doing an asynchronous update, the wait_for_async_ret/1 function can be used to receive the message from Ra. Example: %% Delete the tree node at `/:foo/:bar&#39;. { ok , \#{ [ foo , bar ] := \#{ data := value , payload_version := 1 } , [ baz , bar ] := \#{ payload_version := 1 } } } = khepri_adv : delete_many ( StoreId , [ foo , bar ] ) . See also: delete/3 , khepri:delete/3 .","ref":"khepri_adv.html#delete_many/3","title":"khepri_adv.delete_many/3","type":"function"},{"doc":"Deletes the payload of all tree nodes matching the given path pattern. Calling this function is the same as calling delete_many_payloads(StoreId, PathPattern) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: delete_many_payloads/2 , delete_many_payloads/3 .","ref":"khepri_adv.html#delete_many_payloads/1","title":"khepri_adv.delete_many_payloads/1","type":"function"},{"doc":"Deletes the payload of all tree nodes matching the given path pattern. Calling this function is the same as calling delete_many_payloads(StoreId, PathPattern, \#{}) . See also: delete_many_payloads/3 .","ref":"khepri_adv.html#delete_many_payloads/2","title":"khepri_adv.delete_many_payloads/2","type":"function"},{"doc":"Deletes the payload of all tree nodes matching the given path pattern. In other words, the payload is set to khepri_payload:no_payload() . Otherwise, the behavior is that of put/4 . See also: delete_many/3 , put/4 , khepri:delete_many_payloads/3 .","ref":"khepri_adv.html#delete_many_payloads/3","title":"khepri_adv.delete_many_payloads/3","type":"function"},{"doc":"Deletes the payload of the tree node pointed to by the given path pattern. Calling this function is the same as calling delete_payload(StoreId, PathPattern) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: delete_payload/2 , delete_payload/3 .","ref":"khepri_adv.html#delete_payload/1","title":"khepri_adv.delete_payload/1","type":"function"},{"doc":"Deletes the payload of the tree node pointed to by the given path pattern. Calling this function is the same as calling delete_payload(StoreId, PathPattern, \#{}) . See also: delete_payload/3 .","ref":"khepri_adv.html#delete_payload/2","title":"khepri_adv.delete_payload/2","type":"function"},{"doc":"Deletes the payload of the tree node pointed to by the given path pattern. In other words, the payload is set to khepri_payload:no_payload() . Otherwise, the behavior is that of update/4 . See also: update/4 , khepri:delete_payload/3 .","ref":"khepri_adv.html#delete_payload/3","title":"khepri_adv.delete_payload/3","type":"function"},{"doc":"Returns the properties and payload of the tree node pointed to by the given path pattern. Calling this function is the same as calling get(StoreId, PathPattern) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: get/2 , get/3 .","ref":"khepri_adv.html#get/1","title":"khepri_adv.get/1","type":"function"},{"doc":"Returns the properties and payload of the tree node pointed to by the given path pattern. This function accepts the following two forms: get(StoreId, PathPattern) . Calling it is the same as calling get(StoreId, PathPattern, \#{}) . get(PathPattern, Options) . Calling it is the same as calling get(StoreId, PathPattern, Options) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: get/3 .","ref":"khepri_adv.html#get/2","title":"khepri_adv.get/2","type":"function"},{"doc":"Returns the properties and payload of the tree node pointed to by the given path pattern. The PathPattern can be provided as a native path pattern (a list of tree node names and conditions) or as a string. See khepri_path:from_string/1 . The PathPattern must target a specific tree node. In other words, updating many nodes with the same payload is denied. That fact is checked before the tree node is looked up: so if a condition in the path could potentially match several nodes, an exception is raised, even though only one tree node would match at the time. If you want to get multiple nodes at once, use get_many/3 . The returned {ok, NodeProps} tuple contains a map with the properties and payload (if any) of the targeted tree node. If the tree node is not found, {error, ?khepri_error(node_not_found, Info)} is returned. Example: query a tree node which holds the atom value %% Query the tree node at `/:foo/:bar&#39;. { ok , \#{ data := value , payload_version := 1 } } = khepri_adv : get ( StoreId , [ foo , bar ] ) . Example: query an existing tree node with no payload %% Query the tree node at `/:no_payload&#39;. { ok , \#{ payload_version := 1 } } = khepri_adv : get ( StoreId , [ no_payload ] ) . Example: query a non-existent tree node %% Query the tree node at `/:non_existent&#39;. { error , ? khepri_error ( node_not_found , _ ) } = khepri_adv : get ( StoreId , [ non_existent ] ) . See also: get_many/3 , khepri:get/3 .","ref":"khepri_adv.html#get/3","title":"khepri_adv.get/3","type":"function"},{"doc":"Returns properties and payloads of all the tree nodes matching the given path pattern. Calling this function is the same as calling get_many(StoreId, PathPattern) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: get_many/2 , get_many/3 .","ref":"khepri_adv.html#get_many/1","title":"khepri_adv.get_many/1","type":"function"},{"doc":"Returns properties and payloads of all the tree nodes matching the given path pattern. This function accepts the following two forms: get_many(StoreId, PathPattern) . Calling it is the same as calling get_many(StoreId, PathPattern, \#{}) . get_many(PathPattern, Options) . Calling it is the same as calling get_many(StoreId, PathPattern, Options) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: get_many/3 .","ref":"khepri_adv.html#get_many/2","title":"khepri_adv.get_many/2","type":"function"},{"doc":"Returns properties and payloads of all the tree nodes matching the given path pattern. The PathPattern can be provided as a native path pattern (a list of tree node names and conditions) or as a string. See khepri_path:from_string/1 . The returned {ok, NodePropsMap} tuple contains a map where keys correspond to the path to a tree node matching the path pattern. Each key then points to a map containing the properties and payload (if any) of that matching tree node. Example: query all nodes in the tree %% Get all nodes in the tree. The tree is: %% &lt;root&gt; %% `-- foo %% `-- bar = value { ok , \#{ [ foo ] := \#{ payload_version := 1 } , [ foo , bar ] := \#{ data := value , payload_version := 1 } } } = khepri_adv : get_many ( StoreId , [ ? KHEPRI_WILDCARD_STAR_STAR ] ) . See also: get/3 , khepri:get_many/3 .","ref":"khepri_adv.html#get_many/3","title":"khepri_adv.get_many/3","type":"function"},{"doc":"Sets the payload of the tree node pointed to by the given path pattern. Calling this function is the same as calling put(StoreId, PathPattern, Data) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: put/3 , put/4 .","ref":"khepri_adv.html#put/2","title":"khepri_adv.put/2","type":"function"},{"doc":"Sets the payload of the tree node pointed to by the given path pattern. Calling this function is the same as calling put(StoreId, PathPattern, Data, \#{}) . See also: put/4 .","ref":"khepri_adv.html#put/3","title":"khepri_adv.put/3","type":"function"},{"doc":"Sets the payload of the tree node pointed to by the given path pattern. The PathPattern can be provided as a native path pattern (a list of tree node names and conditions) or as a string. See khepri_path:from_string/1 . The PathPattern must target a specific tree node. In other words, updating many nodes with the same payload is denied. That fact is checked before the tree node is looked up: so if a condition in the path could potentially match several nodes, an exception is raised, even though only one tree node would match at the time. When using a simple path (i.e. without conditions), if the targeted tree node does not exist, it is created using the given payload. If the targeted tree node exists, it is updated with the given payload and its payload version is increased by one. Missing parent nodes are created on the way. When using a path pattern, the behavior is the same. However if a condition in the path pattern is not met, an error is returned and the tree structure is not modified. The returned {ok, NodeProps} tuple contains a map with the properties and payload (if any) of the targeted tree node: the payload was the one before the update, other properties like the payload version correspond to the updated node. If the targeted tree node didn't exist, NodeProps will be an empty map. The payload must be one of the following form: An explicit absence of payload ( khepri_payload:no_payload() ), using the marker returned by khepri_payload:none/0 , meaning there will be no payload attached to the tree node and the existing payload will be discarded if any An anonymous function; it will be considered a stored procedure and will be wrapped in a khepri_payload:sproc() record Any other term; it will be wrapped in a khepri_payload:data() record It is possible to wrap the payload in its internal structure explicitly using the khepri_payload module directly. The Options map may specify command-level options; see khepri:command_options() , khepri:tree_options() and khepri:put_options() . When doing an asynchronous update, the wait_for_async_ret/1 function can be used to receive the message from Ra. The returned {ok, NodeProps} tuple contains a map with the properties and payload (if any) of the targeted tree node as they were before the put. Example: %% Insert a tree node at `/:foo/:bar&#39;, overwriting the previous value. { ok , \#{ data := value , payload_version := 1 } } = khepri_adv : put ( StoreId , [ foo , bar ] , new_value ) . See also: compare_and_swap/5 , create/4 , update/4 , khepri:put/4 .","ref":"khepri_adv.html#put/4","title":"khepri_adv.put/4","type":"function"},{"doc":"Sets the payload of all the tree nodes matching the given path pattern. Calling this function is the same as calling put_many(StoreId, PathPattern, Data) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: put_many/3 , put_many/4 .","ref":"khepri_adv.html#put_many/2","title":"khepri_adv.put_many/2","type":"function"},{"doc":"Sets the payload of all the tree nodes matching the given path pattern. Calling this function is the same as calling put_many(StoreId, PathPattern, Data, \#{}) . See also: put_many/4 .","ref":"khepri_adv.html#put_many/3","title":"khepri_adv.put_many/3","type":"function"},{"doc":"Sets the payload of all the tree nodes matching the given path pattern. The PathPattern can be provided as a native path pattern (a list of tree node names and conditions) or as a string. See khepri_path:from_string/1 . When using a simple path (i.e. without conditions), if the targeted tree node does not exist, it is created using the given payload. If the targeted tree node exists, it is updated with the given payload and its payload version is increased by one. Missing parent nodes are created on the way. When using a path pattern, the behavior is the same. However if a condition in the path pattern is not met, an error is returned and the tree structure is not modified. The returned {ok, NodePropsMap} tuple contains a map where keys correspond to the path to a tree node matching the path pattern. Each key then points to a map containing the properties and payload (if any) of the targeted tree node: the payload was the one before the update, other properties like the payload version correspond to the updated node. The payload must be one of the following form: An explicit absence of payload ( khepri_payload:no_payload() ), using the marker returned by khepri_payload:none/0 , meaning there will be no payload attached to the tree node and the existing payload will be discarded if any An anonymous function; it will be considered a stored procedure and will be wrapped in a khepri_payload:sproc() record Any other term; it will be wrapped in a khepri_payload:data() record It is possible to wrap the payload in its internal structure explicitly using the khepri_payload module directly. The Options map may specify command-level options; see khepri:command_options() , khepri:tree_options() and khepri:put_options() . When doing an asynchronous update, the wait_for_async_ret/1 function can be used to receive the message from Ra. Example: %% Set value of all tree nodes matching `/*/:bar&#39;, to `new_value&#39;. { ok , \#{ [ foo , bar ] := \#{ data := value , payload_version := 1 } , [ baz , bar ] := \#{ payload_version := 1 } } } = khepri_adv : put_many ( StoreId , [ ? KHEPRI_WILDCARD_STAR , bar ] , new_value ) . See also: put/4 , khepri:put_many/4 .","ref":"khepri_adv.html#put_many/4","title":"khepri_adv.put_many/4","type":"function"},{"doc":"Updates an existing tree node with the given payload. Calling this function is the same as calling update(StoreId, PathPattern, Data) with the default store ID (see khepri_cluster:get_default_store_id/0 ). See also: update/3 , update/4 .","ref":"khepri_adv.html#update/2","title":"khepri_adv.update/2","type":"function"},{"doc":"Updates an existing tree node with the given payload. Calling this function is the same as calling update(StoreId, PathPattern, Data, \#{}) . See also: update/4 .","ref":"khepri_adv.html#update/3","title":"khepri_adv.update/3","type":"function"},{"doc":"Updates an existing tree node with the given payload. The behavior is the same as put/4 except that if the tree node already exists, an {error, ?khepri_error(mismatching_node, Info)} tuple is returned. Internally, the PathPattern is modified to include an #if_node_exists{exists = true} condition on its last component. See also: create/4 , put/4 , khepri:update/4 .","ref":"khepri_adv.html#update/4","title":"khepri_adv.update/4","type":"function"},{"doc":"Return value of a query or synchronous command targeting many tree nodes.","ref":"khepri_adv.html#t:many_results/0","title":"khepri_adv.many_results/0","type":"type"},{"doc":"Structure used to return a map of nodes and their associated properties, payload and child nodes.","ref":"khepri_adv.html#t:node_props_map/0","title":"khepri_adv.node_props_map/0","type":"type"},{"doc":"Return value of a query or synchronous command targeting one specific tree node.","ref":"khepri_adv.html#t:single_result/0","title":"khepri_adv.single_result/0","type":"type"},{"doc":"","ref":"khepri_app.html","title":"khepri_app","type":"module"},{"doc":"","ref":"khepri_app.html#config_change/3","title":"khepri_app.config_change/3","type":"function"},{"doc":"","ref":"khepri_app.html#get_default_timeout/0","title":"khepri_app.get_default_timeout/0","type":"function"},{"doc":"","ref":"khepri_app.html#start/2","title":"khepri_app.start/2","type":"function"},{"doc":"","ref":"khepri_app.html#stop/1","title":"khepri_app.stop/1","type":"function"},{"doc":"Khepri service and cluster management API. This module provides the public API for the service and cluster management. For convenience, some functions of this API are repeated in the khepri module for easier access. The Khepri store and the Ra cluster A Khepri store is a Ra server inside a Ra cluster. The Khepri store and the Ra cluster share the same name in fact. The only constraint is that the name must be an atom, even though Ra accepts other Erlang types as cluster names. By default, Khepri uses khepri as the store ID (and thus Ra cluster name). This default can be overridden using an argument to the start/0 functions or the default_store_id application environment variable. Examples: Use the default Khepri store ID: { ok , khepri } = khepri : start ( ) . Override the default store ID using an argument: { ok , my_store } = khepri : start ( &quot;/var/lib/khepri&quot; , my_store ) . Override the default store ID using an application environment variable: ok = application : set_env ( khepri , default_store_id , my_store , [ { persistent , true } ] ) , { ok , my_store } = khepri : start ( ) . The data directory and the Ra system A Ra server relies on a Ra system to provide various functions and to configure the directory where the data should be stored on disk. By default, Khepri will configure its own Ra system to write data under khepri in the current working directory, where Nodename is the name of the Erlang node. { ok , StoreId } = khepri : start ( ) . %% If the Erlang node was started without distribution (the default), the %% statement above will start a Ra system called like the store (`khepri&#39;) %% and will use the `khepri#nonode@nohost&#39; directory. The default data directory or Ra system name can be overridden using an argument to the start/0 or the default_ra_system application environment variable. Both a directory (string or binary) or the name of an already running Ra system are accepted. Examples: Override the default with the name of a running Ra system using an argument: { ok , StoreId } = khepri : start ( my_ra_system ) . Override the default data directory using an application environment variable: ok = application : set_env ( khepri , default_ra_system , &quot;/var/lib/khepri&quot; , [ { persistent , true } ] ) , { ok , StoreId } = khepri : start ( ) . Please refer to Ra documentation to learn more about Ra systems and Ra clusters. Managing Ra cluster members A Khepri/Ra cluster can be expanded by telling a node to join a remote cluster. Note that the Khepri store/Ra server to add to the cluster must run before it can join. %% Start the local Khepri store. { ok , StoreId } = khepri : start ( ) . %% Join a remote cluster. ok = khepri_cluster : join ( RemoteNode ) . To remove the local Khepri store node from the cluster, it must be reset. %% Start the local Khepri store. ok = khepri_cluster : reset ( ) .","ref":"khepri_cluster.html","title":"khepri_cluster","type":"module"},{"doc":"","ref":"khepri_cluster.html#cache_leader/2","title":"khepri_cluster.cache_leader/2","type":"function"},{"doc":"","ref":"khepri_cluster.html#cache_leader_if_changed/3","title":"khepri_cluster.cache_leader_if_changed/3","type":"function"},{"doc":"","ref":"khepri_cluster.html#clear_cached_leader/1","title":"khepri_cluster.clear_cached_leader/1","type":"function"},{"doc":"","ref":"khepri_cluster.html#get_cached_leader/1","title":"khepri_cluster.get_cached_leader/1","type":"function"},{"doc":"Returns the default Ra system name or data directory. This is based on Khepri's default_ra_system` application environment variable. The variable can be set to: &lt;ul&gt; &lt;li&gt;A directory (a string or binary) where data should be stored. A new Ra system called `khepri` will be initialized with this directory.&lt;/li&gt; &lt;li&gt;A Ra system name (an atom). In this case, the user is expected to configure and start the Ra system before starting Khepri.&lt;/li&gt; &lt;/ul&gt; If this application environment variable is unset, the default is to configure a Ra system called `khepri which will write data in &quot;khepri-$NODE&quot; in the current working directory where $NODE is the Erlang node name. Example of an Erlang configuration file for Khepri: { khepri , [ { default_ra_system , &quot;/var/db/khepri&quot; } ] } .","ref":"khepri_cluster.html#get_default_ra_system_or_data_dir/0","title":"khepri_cluster.get_default_ra_system_or_data_dir/0","type":"function"},{"doc":"Returns the default Khepri store ID. This is based on Khepri's default_store_id application environment variable. The variable can be set to an atom. The default is khepri .","ref":"khepri_cluster.html#get_default_store_id/0","title":"khepri_cluster.get_default_store_id/0","type":"function"},{"doc":"Returns the list of running stores.","ref":"khepri_cluster.html#get_store_ids/0","title":"khepri_cluster.get_store_ids/0","type":"function"},{"doc":"Adds the local running Khepri store to a remote cluster. This function accepts the following forms: join(RemoteNode) . Calling it is the same as calling join(DefaultStoreId, RemoteNode) where DefaultStoreId is returned by get_default_store_id/0 . join(RemoteMember) . Calling it is the same as calling join(StoreId, RemoteNode) where StoreId and RemoteNode are derived from RemoteMember . See also: join/2 .","ref":"khepri_cluster.html#join/1","title":"khepri_cluster.join/1","type":"function"},{"doc":"Adds the local running Khepri store to a remote cluster. This function accepts the following forms: join(RemoteNode, Timeout) . Calling it is the same as calling join(DefaultStoreId, RemoteNode, Timeout) where DefaultStoreId is returned by get_default_store_id/0 . join(StoreId, RemoteNode) . Calling it is the same as calling join(StoreId, RemoteNode, DefaultTimeout) where DefaultTimeout is returned by khepri_app:get_default_timeout/0 . join(RemoteMember, Timeout) . Calling it is the same as calling join(StoreId, RemoteNode, Timeout) where StoreId and RemoteNode are derived from RemoteMember . See also: join/3 .","ref":"khepri_cluster.html#join/2","title":"khepri_cluster.join/2","type":"function"},{"doc":"","ref":"khepri_cluster.html#locally_known_members/1","title":"khepri_cluster.locally_known_members/1","type":"function"},{"doc":"","ref":"khepri_cluster.html#locally_known_members/2","title":"khepri_cluster.locally_known_members/2","type":"function"},{"doc":"","ref":"khepri_cluster.html#locally_known_nodes/1","title":"khepri_cluster.locally_known_nodes/1","type":"function"},{"doc":"","ref":"khepri_cluster.html#members/1","title":"khepri_cluster.members/1","type":"function"},{"doc":"","ref":"khepri_cluster.html#members/2","title":"khepri_cluster.members/2","type":"function"},{"doc":"","ref":"khepri_cluster.html#nodes/1","title":"khepri_cluster.nodes/1","type":"function"},{"doc":"Resets the store on this Erlang node.","ref":"khepri_cluster.html#reset/0","title":"khepri_cluster.reset/0","type":"function"},{"doc":"Resets the store on this Erlang node.","ref":"khepri_cluster.html#reset/1","title":"khepri_cluster.reset/1","type":"function"},{"doc":"Resets the store on this Erlang node. It does that by force-deleting the Ra local server. This function is also used to gracefully remove the local Khepri store node from a cluster.","ref":"khepri_cluster.html#reset/2","title":"khepri_cluster.reset/2","type":"function"},{"doc":"Starts a store. Calling this function is the same as calling start(DefaultRaSystem) where DefaultRaSystem is returned by get_default_ra_system_or_data_dir/0 . See also: start/1 , ra_server:ra_server_config/0.","ref":"khepri_cluster.html#start/0","title":"khepri_cluster.start/0","type":"function"},{"doc":"Starts a store. Calling this function is the same as calling start(RaSystemOrDataDir, DefaultStoreId) where DefaultStoreId is returned by get_default_store_id/0 . See also: start/2 .","ref":"khepri_cluster.html#start/1","title":"khepri_cluster.start/1","type":"function"},{"doc":"Starts a store. Calling this function is the same as calling start(RaSystemOrDataDir, StoreIdOrRaServerConfig, DefaultTimeout) where DefaultTimeout is returned by khepri_app:get_default_timeout/0 . See also: start/3 .","ref":"khepri_cluster.html#start/2","title":"khepri_cluster.start/2","type":"function"},{"doc":"Starts a store. It accepts either a Ra system name (atom) or a data directory (string or binary) as its first argument. If a Ra system name is given, that Ra system must be running when this function is called. If a data directory is given, a new Ra system will be started, using this directory. The directory will be created automatically if it doesn't exist. The Ra system will use the same name as the Khepri store. It accepts a Khepri store ID or a Ra server configuration as its second argument. If a store ID is given, a Ra server configuration will be created based on it. If a Ra server configuration is given, the name of the Khepri store will be derived from it. If this is a new store, the Ra server is started and an election is triggered so that it becomes its own leader and is ready to process commands and queries. If the store was started in the past and stopped, it will be restarted. In this case, RaServerConfig will be ignored. Ra will take care of the eletion automatically.","ref":"khepri_cluster.html#start/3","title":"khepri_cluster.start/3","type":"function"},{"doc":"Stops a store. Calling this function is the same as calling stop(DefaultStoreId) where DefaultStoreId is returned by get_default_store_id/0 . See also: stop/1 .","ref":"khepri_cluster.html#stop/0","title":"khepri_cluster.stop/0","type":"function"},{"doc":"Stops a store.","ref":"khepri_cluster.html#stop/1","title":"khepri_cluster.stop/1","type":"function"},{"doc":"A Ra server config map. This configuration map can lack the required parameters, Khepri will fill them if necessary. Important parameters for Khepri (e.g. machine ) will be overridden anyway.","ref":"khepri_cluster.html#t:incomplete_ra_server_config/0","title":"khepri_cluster.incomplete_ra_server_config/0","type":"type"},{"doc":"Intermediate Ra server configuration with cluster_name set.","ref":"khepri_cluster.html#t:ra_server_config_with_cluster_name/0","title":"khepri_cluster.ra_server_config_with_cluster_name/0","type":"type"},{"doc":"Intermediate Ra server configuration with id and cluster_name set.","ref":"khepri_cluster.html#t:ra_server_config_with_id_and_cn/0","title":"khepri_cluster.ra_server_config_with_id_and_cn/0","type":"type"},{"doc":"Condition support. Conditions can be used in path patterns and keep_while conditions. They allow to point to a specific node only if conditions are met, or to match several tree nodes with a single path pattern. A condition is an Erlang record defining a specific property. Some of them have arguments to further define the condition. Path components (atoms and binaries) also act as conditions which check equality with the path of the tested node. This can be useful for conditions which compose other conditions: if_not() , if_all() and if_any() . Example: %% Matches `[stock, wood, &lt;&lt;&quot;birch&quot;&gt;&gt;]&#39; but not `[stock, wood, &lt;&lt;&quot;oak&quot;&gt;&gt;]&#39; [ stock , wood , # if_not { condition = &lt;&lt; &quot;oak&quot; &gt;&gt; } ] All supported conditions are described in the Data Types section .","ref":"khepri_condition.html","title":"khepri_condition","type":"module"},{"doc":"","ref":"khepri_condition.html#ensure_native_keep_while/1","title":"khepri_condition.ensure_native_keep_while/1","type":"function"},{"doc":"Comparison operator in some condition() .","ref":"khepri_condition.html#t:comparison_op/1","title":"khepri_condition.comparison_op/1","type":"type"},{"doc":"All supported conditions.","ref":"khepri_condition.html#t:condition/0","title":"khepri_condition.condition/0","type":"type"},{"doc":"","ref":"khepri_condition.html#t:condition_using_comparison_op/0","title":"khepri_condition.condition_using_comparison_op/0","type":"type"},{"doc":"","ref":"khepri_condition.html#t:condition_using_regex/0","title":"khepri_condition.condition_using_regex/0","type":"type"},{"doc":"Condition. Evaluates to true if all inner conditions evaluate to true. Record fields: conditions : a list of inner conditions to evaluate. Example: # if_all { conditions = [ # if_name_matches { regex = &quot;^a&quot; } , # if_has_data { has_data = true } ] } .","ref":"khepri_condition.html#t:if_all/0","title":"khepri_condition.if_all/0","type":"type"},{"doc":"Condition. Evaluates to true if any of the inner conditions evaluate to true. Record fields: conditions : a list of inner conditions to evaluate. Example: # if_any { conditions = [ # if_name_matches { regex = &quot;^a&quot; } , # if_has_data { has_data = true } ] } .","ref":"khepri_condition.html#t:if_any/0","title":"khepri_condition.if_any/0","type":"type"},{"doc":"Condition. Evaluates to true if the tested node's child list size corresponds to the expected value. Record fields: version : integer or comparison_op() to compare to the actual child list child. Example: # if_child_list_length { count = 1 } . # if_child_list_length { count = { gt , 10 } } .","ref":"khepri_condition.html#t:if_child_list_length/0","title":"khepri_condition.if_child_list_length/0","type":"type"},{"doc":"Condition. Evaluates to true if the tested node's child list version corresponds to the expected value. Record fields: version : integer or comparison_op() to compare to the actual child list version. Example: # if_child_list_version { version = 1 } . # if_child_list_version { version = { gt , 10 } } .","ref":"khepri_condition.html#t:if_child_list_version/0","title":"khepri_condition.if_child_list_version/0","type":"type"},{"doc":"Condition. Evaluates to true if the tested node has a data payload and the data payload term matches the given pattern and all conditions evaluates to true. Record fields: pattern : an ETS-like match pattern. The match pattern can define variables to be used in the conditions below. conditions : a list of guard expressions. All guard expressions must evaluate to true to consider a match. The default is an empty list of conditions which means that only the pattern matching is considered. Examples: %% The data must be of the form `{user, _}&#39;, so a tuple of arity 2 with the %% first element being the `user&#39; atom. The second element can be anything. # if_data_matches { pattern = { user , &#39;_&#39; } } . %% The data must be of the form `{age, Age}&#39; and `Age&#39; must be an %% integer greater than or equal to 18. # if_data_matches { pattern = { age , &#39;$1&#39; } , conditions = [ { is_integer , &#39;$1&#39; } , { &#39;&gt;=&#39; , &#39;$1&#39; , 18 } ] } . See Match Specifications in Erlang for a detailed documentation of how it works.","ref":"khepri_condition.html#t:if_data_matches/0","title":"khepri_condition.if_data_matches/0","type":"type"},{"doc":"Condition. Evaluates to true if the tested node's data payload presence corresponds to the expected state. Record fields: has_data : boolean set to the expected presence of a data payload. Data absence is either no payload or a non-data type of payload. Example: # if_has_data { has_data = false } .","ref":"khepri_condition.html#t:if_has_data/0","title":"khepri_condition.if_has_data/0","type":"type"},{"doc":"Condition. Evaluates to true if the name of the tested node matches the condition pattern. Record fields: regex : defines the condition pattern. It can be either: a regular expression the atom any to match any node names; the equivalent of the &quot;.*&quot; regular expression but more efficient Example: # if_name_matches { regex = &quot;^user_&quot; } . # if_name_matches { regex = any } .","ref":"khepri_condition.html#t:if_name_matches/0","title":"khepri_condition.if_name_matches/0","type":"type"},{"doc":"Condition. Evaluates to true if the tested node existence corresponds to the expected state. Record fields: exists : boolean set to the expected presence of the node. Example: # if_node_exists { exists = false } .","ref":"khepri_condition.html#t:if_node_exists/0","title":"khepri_condition.if_node_exists/0","type":"type"},{"doc":"Condition. Evaluates to true if the inner condition evaluates to false. Record fields: condition : the inner condition to evaluate. Example: # if_not { condition = # if_name_matches { regex = &quot;^a&quot; } } .","ref":"khepri_condition.html#t:if_not/0","title":"khepri_condition.if_not/0","type":"type"},{"doc":"Condition. Evaluates to true if the name of the tested node matches the condition pattern. If it does not match, child node names are tested recursively. Record fields: regex : defines the condition pattern. It can be either: a regular expression the atom any to match any node names; the equivalent of the &quot;.*&quot; regular expression but more efficient Example: # if_path_matches { regex = &quot;^user_&quot; } . # if_path_matches { regex = any } .","ref":"khepri_condition.html#t:if_path_matches/0","title":"khepri_condition.if_path_matches/0","type":"type"},{"doc":"Condition. Evaluates to true if the tested node's payload version corresponds to the expected value. Record fields: version : integer or comparison_op() to compare to the actual payload version. Example: # if_payload_version { version = 1 } . # if_payload_version { version = { gt , 10 } } .","ref":"khepri_condition.html#t:if_payload_version/0","title":"khepri_condition.if_payload_version/0","type":"type"},{"doc":"An association between a path and a condition. As long as the condition evaluates to true, the tree node is kept. Once the condition evaluates to false, the tree node is deleted. If the keep_while conditions are false at the time of the insert, the insert fails. The only exception to that is if the keep_while condition is on the inserted node itself. Paths in the map can be native paths or Unix-like paths. However, having two entries that resolve to the same node (one native path entry and one Unix-like path entry for instance) is undefined behavior: one of them will overwrite the other. Example: khepri : put ( StoreId , [ foo ] , Payload , \#{ keep_while =&gt; \#{ %% The node `[foo]&#39; will be removed as soon as `[bar]&#39; is removed %% because the condition associated with `[bar]&#39; will not be true %% anymore. [ bar ] =&gt; # if_node_exists { exists = true } } } ) .","ref":"khepri_condition.html#t:keep_while/0","title":"khepri_condition.keep_while/0","type":"type"},{"doc":"An association between a native path and a condition. This is the same as keep_while() but the paths in the map keys were converted to native paths if necessary.","ref":"khepri_condition.html#t:native_keep_while/0","title":"khepri_condition.native_keep_while/0","type":"type"},{"doc":"Return value of re:compile/1 . The opaque compiled regex type, re:mp() , is unfortunately not exported by re , neither is the error tuple (at least up to Erlang/OTP 25.1).","ref":"khepri_condition.html#t:re_compile_ret/0","title":"khepri_condition.re_compile_ret/0","type":"type"},{"doc":"","ref":"khepri_event_handler.html","title":"khepri_event_handler","type":"module"},{"doc":"","ref":"khepri_event_handler.html#code_change/3","title":"khepri_event_handler.code_change/3","type":"function"},{"doc":"","ref":"khepri_event_handler.html#handle_call/3","title":"khepri_event_handler.handle_call/3","type":"function"},{"doc":"","ref":"khepri_event_handler.html#handle_cast/2","title":"khepri_event_handler.handle_cast/2","type":"function"},{"doc":"","ref":"khepri_event_handler.html#handle_info/2","title":"khepri_event_handler.handle_info/2","type":"function"},{"doc":"","ref":"khepri_event_handler.html#handle_triggered_sprocs/2","title":"khepri_event_handler.handle_triggered_sprocs/2","type":"function"},{"doc":"","ref":"khepri_event_handler.html#init/1","title":"khepri_event_handler.init/1","type":"function"},{"doc":"","ref":"khepri_event_handler.html#start_link/0","title":"khepri_event_handler.start_link/0","type":"function"},{"doc":"","ref":"khepri_event_handler.html#terminate/2","title":"khepri_event_handler.terminate/2","type":"function"},{"doc":"Khepri event filters.","ref":"khepri_evf.html","title":"khepri_evf","type":"module"},{"doc":"Returns the priority of the event filter.","ref":"khepri_evf.html#get_priority/1","title":"khepri_evf.get_priority/1","type":"function"},{"doc":"Sets the priority of the event filter.","ref":"khepri_evf.html#set_priority/2","title":"khepri_evf.set_priority/2","type":"function"},{"doc":"Constructs a tree event filter. See also: tree/2 .","ref":"khepri_evf.html#tree/1","title":"khepri_evf.tree/1","type":"function"},{"doc":"Constructs a tree event filter. See also: tree_event_filter() .","ref":"khepri_evf.html#tree/2","title":"khepri_evf.tree/2","type":"function"},{"doc":"Automatically detects the event filter type and ensures it is wrapped in one of the internal types.","ref":"khepri_evf.html#wrap/1","title":"khepri_evf.wrap/1","type":"function"},{"doc":"An event filter. The following event filters are supported: Tree event filter ( tree_event_filter() An event filter can be explicitly constructed using the functions provided in this module. However, some common types will be automatically detected and converted to an event filter with default properties. See each event filter type for more details.","ref":"khepri_evf.html#t:event_filter/0","title":"khepri_evf.event_filter/0","type":"type"},{"doc":"An event filter priority. This is an integer to prioritize event filters: the greater the priority, the more it is prioritized. Negative integers are allowed. The default priority is 0.","ref":"khepri_evf.html#t:priority/0","title":"khepri_evf.priority/0","type":"type"},{"doc":"A tree event filter. It takes a path pattern to monitor and optionally properties.","ref":"khepri_evf.html#t:tree_event_filter/0","title":"khepri_evf.tree_event_filter/0","type":"type"},{"doc":"Tree event filter properties. The properties are: on_actions : a list of actions to filter among create , update and delete ; the default is to react to all of them. priority : a priority() A Khepri path, whether it is a native path or a Unix-like path, can be used as a tree event filter. It will be automatically converted to a tree event filter with default properties.","ref":"khepri_evf.html#t:tree_event_filter_props/0","title":"khepri_evf.tree_event_filter_props/0","type":"type"},{"doc":"Anonymous function extraction private API. This module is responsible for extracting the code of an anonymous function. The goal is to be able to store the extracted function and execute it later, regardless of the availability of the initial Erlang module which declared it. This module also provides a way for the caller to indicate forbidden operations or function calls. This module works on assembly code to perform all checks and prepare the storable copy of a function. It uses beam_disasm:file/1 from the compiler application to extract the assembly code. After the assembly code was extracted and modified, the compiler is used again to compile the code back to an executable module. If the anonymous function calls other functions, either in the same module or in another one, the code of the called functions is extracted and copied as well. This is to make sure the result is completely standalone. To avoid any copies of standard Erlang APIs or Khepri itself, it is possible to specify a list of modules which should not be copied. In this case, calls to functions in those modules are left unmodified. Once the code was extracted and verified, a new module is generated as an &quot;assembly form&quot;, ready to be compiled again to an executable module. The generated module has a single run/N function. This function contains the code of the extracted anonymous function. Because this process works on the assembly code, it means that if the initial module hosting the anonymous function was compiled with Erlang version N, it will probably not compile or run on older versions of Erlang. The reason is that a newer compiler may use instructions which are unknown to older runtimes. There is a special treatment for anonymous functions evaluated by erl_eval (e.g. in the Erlang shell). &quot;erl_eval functions&quot; are lambdas parsed from text and are evaluated using erl_eval . This kind of lambdas becomes a local function in the erl_eval module. Their assembly code isn't available in the erl_eval module. However, the abstract code (i.e. after parsing but before compilation) is available in the env . We compile that abstract code and extract the assembly from that compiled beam. This module is private. The documentation is still visible because it may help understand some implementation details. However, this module should never be called directly outside of Khepri.","ref":"khepri_fun.html","title":"khepri_fun","type":"module"},{"doc":"Executes a previously extracted anonymous function. This is the equivalent of erlang:apply/2 but it supports extracted anonymous functions. The list of Args must match the arity of the anonymous function.","ref":"khepri_fun.html#exec/2","title":"khepri_fun.exec/2","type":"function"},{"doc":"Extracts the given anonymous function This is the same as: khepri_fun : to_standalone_fun ( Fun , \#{ } ) .","ref":"khepri_fun.html#to_standalone_fun/1","title":"khepri_fun.to_standalone_fun/1","type":"function"},{"doc":"Extracts the given anonymous function","ref":"khepri_fun.html#to_standalone_fun/2","title":"khepri_fun.to_standalone_fun/2","type":"function"},{"doc":"","ref":"khepri_fun.html#t:asm/0","title":"khepri_fun.asm/0","type":"type"},{"doc":"","ref":"khepri_fun.html#t:beam_instr/0","title":"khepri_fun.beam_instr/0","type":"type"},{"doc":"Function which evaluates the given instruction and returns ok if it is permitted, throws an exception otherwise. Example: Fun = fun ( { jump , _ } ) -&gt; ok ; ( { move , _ , _ } ) -&gt; ok ; ( { trim , _ , _ } ) -&gt; ok ; ( Unknown ) -&gt; throw ( { unknown_instruction , Unknown } ) end .","ref":"khepri_fun.html#t:ensure_instruction_is_permitted_fun/0","title":"khepri_fun.ensure_instruction_is_permitted_fun/0","type":"type"},{"doc":"","ref":"khepri_fun.html#t:fun_info/0","title":"khepri_fun.fun_info/0","type":"type"},{"doc":"Function which evaluates if the extracted function is still relevant in the end. It returns true if it is, false otherwise. It takes a map with the following members: calls , a map of all the calls performed by the extracted code (only the key is useful, the value is always true). errors , a list of errors collected during the extraction.","ref":"khepri_fun.html#t:is_standalone_fun_still_needed_fun/0","title":"khepri_fun.is_standalone_fun_still_needed_fun/0","type":"type"},{"doc":"","ref":"khepri_fun.html#t:label/0","title":"khepri_fun.label/0","type":"type"},{"doc":"Options to tune the extraction of an anonymous function. ensure_instruction_is_permitted : a function which evaluates if an instruction is permitted or not. should_process_function : a function which returns if a called module and function should be extracted as well or left alone. is_standalone_fun_still_needed : a function which returns if, after the extraction is finished, the extracted function is still needed in comparison to keeping the initial anonymous function.","ref":"khepri_fun.html#t:options/0","title":"khepri_fun.options/0","type":"type"},{"doc":"Function which returns true if a called function should be extracted and followed, false otherwise. Module , Function and Arity qualify the function being called. FromModule indicates the module performing the call. This is useful to distinguish local calls ( FromModule == Module ) from remote calls. Example: Fun = fun ( Module , Name , Arity , FromModule ) -&gt; Module =:= FromModule orelse erlang : function_exported ( Module , Name , Arity ) end .","ref":"khepri_fun.html#t:should_process_function_fun/0","title":"khepri_fun.should_process_function_fun/0","type":"type"},{"doc":"The result of an extraction, as returned by to_standalone_fun/2 . It can be stored, passed between processes and Erlang nodes. To execute the extracted function, simply call exec/2 which works like erlang:apply/2 .","ref":"khepri_fun.html#t:standalone_fun/0","title":"khepri_fun.standalone_fun/0","type":"type"},{"doc":"Khepri private low-level API. This module exposes the private &quot;low-level&quot; API to the Khepri database and state machine. Main functions correspond to Ra commands implemented by the state machine. All functions in khepri are built on top of this module. This module is private. The documentation is still visible because it may help understand some implementation details. However, this module should never be called directly outside of Khepri.","ref":"khepri_machine.html","title":"khepri_machine","type":"module"},{"doc":"Counts all tree nodes matching the path pattern.","ref":"khepri_machine.html#count/3","title":"khepri_machine.count/3","type":"function"},{"doc":"Deletes all tree nodes matching the path pattern.","ref":"khepri_machine.html#delete/3","title":"khepri_machine.delete/3","type":"function"},{"doc":"Returns all tree nodes matching the given path pattern.","ref":"khepri_machine.html#get/3","title":"khepri_machine.get/3","type":"function"},{"doc":"","ref":"khepri_machine.html#handle_tx_exception/1","title":"khepri_machine.handle_tx_exception/1","type":"function"},{"doc":"Registers a trigger.","ref":"khepri_machine.html#register_trigger/5","title":"khepri_machine.register_trigger/5","type":"function"},{"doc":"Executes a stored procedure. The stored procedure is executed in the context of the caller of run_sproc/3 .","ref":"khepri_machine.html#run_sproc/4","title":"khepri_machine.run_sproc/4","type":"function"},{"doc":"Runs a transaction and returns the result.","ref":"khepri_machine.html#transaction/4","title":"khepri_machine.transaction/4","type":"function"},{"doc":"","ref":"khepri_machine.html#t:async_ret/0","title":"khepri_machine.async_ret/0","type":"type"},{"doc":"Commands specific to this Ra machine.","ref":"khepri_machine.html#t:command/0","title":"khepri_machine.command/0","type":"type"},{"doc":"","ref":"khepri_machine.html#t:common_ret/0","title":"khepri_machine.common_ret/0","type":"type"},{"doc":"Internal index of the per-node changes which happened during a traversal. This is used when the tree is walked back up to determine the list of tree nodes to remove after some keep_while condition evaluates to false.","ref":"khepri_machine.html#t:keep_while_aftermath/0","title":"khepri_machine.keep_while_aftermath/0","type":"type"},{"doc":"Per-node keep_while conditions.","ref":"khepri_machine.html#t:keep_while_conds_map/0","title":"khepri_machine.keep_while_conds_map/0","type":"type"},{"doc":"Internal reverse index of the keep_while conditions. If node A depends on a condition on node B, then this reverse index will have a &quot;node B =&gt; node A&quot; entry.","ref":"khepri_machine.html#t:keep_while_conds_revidx/0","title":"khepri_machine.keep_while_conds_revidx/0","type":"type"},{"doc":"Configuration record, holding read-only or rarely changing fields.","ref":"khepri_machine.html#t:machine_config/0","title":"khepri_machine.machine_config/0","type":"type"},{"doc":"Structure passed to init/1 .","ref":"khepri_machine.html#t:machine_init_args/0","title":"khepri_machine.machine_init_args/0","type":"type"},{"doc":"","ref":"khepri_machine.html#t:ok/2","title":"khepri_machine.ok/2","type":"type"},{"doc":"","ref":"khepri_machine.html#t:ok/3","title":"khepri_machine.ok/3","type":"type"},{"doc":"Properties attached to each node in the tree structure.","ref":"khepri_machine.html#t:props/0","title":"khepri_machine.props/0","type":"type"},{"doc":"Function representing a query and used process_query/3 .","ref":"khepri_machine.html#t:query_fun/0","title":"khepri_machine.query_fun/0","type":"type"},{"doc":"State of this Ra state machine.","ref":"khepri_machine.html#t:state/0","title":"khepri_machine.state/0","type":"type"},{"doc":"A node in the tree structure.","ref":"khepri_machine.html#t:tree_node/0","title":"khepri_machine.tree_node/0","type":"type"},{"doc":"","ref":"khepri_machine.html#t:triggered/0","title":"khepri_machine.triggered/0","type":"type"},{"doc":"","ref":"khepri_machine.html#t:tx_ret/0","title":"khepri_machine.tx_ret/0","type":"type"},{"doc":"","ref":"khepri_machine.html#t:walk_down_the_tree_extra/0","title":"khepri_machine.walk_down_the_tree_extra/0","type":"type"},{"doc":"Function called to handle a node found (or an error) and used in walk_down_the_tree/6 .","ref":"khepri_machine.html#t:walk_down_the_tree_fun/0","title":"khepri_machine.walk_down_the_tree_fun/0","type":"type"},{"doc":"Khepri path API. A path is the type used by Khepri to reference nodes in the tree structure. A path describes how to reach a node from the root node. A path, or native path , is a list of components. Components can be Erlang atoms and binaries. Example: %% Native path. Path = [ stock , wood , &lt;&lt; &quot;oak&quot; &gt;&gt; ] . A path may contain conditions to tune how a node is matched or to match multiple nodes at once. This is called a path pattern . A path pattern may contain conditions in addition to regular components (Erlang atoms and binaries). See khepri_condition to learn more about conditions. Example: %% Path pattern with a condition on `wood&#39;. PathPattern = [ stock , # if_all { conditions = [ wood , # if_node_exists { exists = true } ] } , oak ] . To be user-friendly, string-based and binary-based Unix-like paths are accepted by most functions. The syntax of these Unix paths is described in the unix_path() type documentation. Example: %% Unix path, equivalent of the first native path example. UnixPath = &quot;/:stock/:wood/oak&quot; .","ref":"khepri_path.html","title":"khepri_path","type":"module"},{"doc":"","ref":"khepri_path.html#abspath/2","title":"khepri_path.abspath/2","type":"function"},{"doc":"","ref":"khepri_path.html#combine_with_conditions/2","title":"khepri_path.combine_with_conditions/2","type":"function"},{"doc":"","ref":"khepri_path.html#ensure_is_valid/1","title":"khepri_path.ensure_is_valid/1","type":"function"},{"doc":"Converts a Unix-like path to a native path. This is the same as calling from_string(String) . Therefore, it accepts Erlang strings or binaries and native paths. See also: from_string/1 .","ref":"khepri_path.html#from_binary/1","title":"khepri_path.from_binary/1","type":"function"},{"doc":"Converts a Unix-like path to a native path. The Unix-like string can be either an Erlang string or an Erlang binary. For convenience, a native path is also accepted and returned as-is.","ref":"khepri_path.html#from_string/1","title":"khepri_path.from_string/1","type":"function"},{"doc":"","ref":"khepri_path.html#is_valid/1","title":"khepri_path.is_valid/1","type":"function"},{"doc":"","ref":"khepri_path.html#pattern_includes_root_node/1","title":"khepri_path.pattern_includes_root_node/1","type":"function"},{"doc":"","ref":"khepri_path.html#realpath/1","title":"khepri_path.realpath/1","type":"function"},{"doc":"","ref":"khepri_path.html#targets_specific_node/1","title":"khepri_path.targets_specific_node/1","type":"function"},{"doc":"Converts a native path to a binary.","ref":"khepri_path.html#to_binary/1","title":"khepri_path.to_binary/1","type":"function"},{"doc":"Converts a native path to a string.","ref":"khepri_path.html#to_string/1","title":"khepri_path.to_string/1","type":"function"},{"doc":"Component name in a path to a node.","ref":"khepri_path.html#t:component/0","title":"khepri_path.component/0","type":"type"},{"doc":"Native path to a node. A native path is a list of atoms, binaries and special components. It is called native because it requires no further processing (unlike unix_path() ) and is the format used internally by the state machine. Special components are: ?KHEPRI_ROOT_NODE to explicitly mark the root node. A path is absolute by default. Using ?KHEPRI_ROOT_NODE is only useful when manipulating the root node itself (querying it or storing something in the root node). ?THIS_KHEPRI_NODE to make a relative path (the default being an absolute path). This is mostly useful for khepri_condition:keep_while() to make it easy to put a condition on the node itself. ?PARENT_KHEPRI_NODE to target the parent of a node, with the same benefits and use cases as ?THIS_KHEPRI_NODE . Example: %% Native path. Path = [ stock , wood , &lt;&lt; &quot;oak&quot; &gt;&gt; ] .","ref":"khepri_path.html#t:native_path/0","title":"khepri_path.native_path/0","type":"type"},{"doc":"Path pattern which may match zero, one or more nodes. A native pattern is a list of atoms, binaries, special components and conditions. It is called native because it requires no further processing (unlike unix_pattern() ) and is the format used internally by the state machine. See native_path() for a description of special components. Conditions are any condition defined by khepri_condition:condition() . Example: %% Path pattern with a condition on `wood&#39;. PathPattern = [ stock , # if_all { conditions = [ wood , # if_node_exists { exists = true } ] } , oak ] .","ref":"khepri_path.html#t:native_pattern/0","title":"khepri_path.native_pattern/0","type":"type"},{"doc":"A node name.","ref":"khepri_path.html#t:node_id/0","title":"khepri_path.node_id/0","type":"type"},{"doc":"Path to a node.","ref":"khepri_path.html#t:path/0","title":"khepri_path.path/0","type":"type"},{"doc":"Path pattern which may match zero, one or more nodes.","ref":"khepri_path.html#t:pattern/0","title":"khepri_path.pattern/0","type":"type"},{"doc":"Path pattern component which may match zero, one or more nodes.","ref":"khepri_path.html#t:pattern_component/0","title":"khepri_path.pattern_component/0","type":"type"},{"doc":"Unix-like path to a node. These Unix paths have the following syntax: Path components are separated by a forward slash, / . Atom-based node IDs are prefixed with a : character: :wood . Binary-based node IDs are written as-is: oak . Atom and binaries can be percent-encoded. An absolute path must start with / , otherwise it is considered a relative path . and .. represent ?THIS_KHEPRI_NODE and ?PARENT_KHEPRI_NODE respectively Simple glob patterns are accepted: abc*def is the same as #if_name_matches{regex = &quot;^abc.*def$&quot;} * is the same as ?KHEPRI_WILDCARD_STAR or #if_name_matches{regex = any} ** is the same as ?KHEPRI_WILDCARD_STAR_STAR or if_path_matches{regex = any} Warning : There is no special handling of Unicode in tree node names. To use Unicode, it is recommended to either use a native path or a binary-based Unix-like path. If using a string-based Unix-like path, the behavior is undefined and the call may crash. Matching against node names is also undefined behavior and may crash, regardless of the type of path being used. It will be improved in the future. Example: %% Unix path, equivalent of the first native path example. UnixPath = &quot;/:stock/:wood/oak&quot; .","ref":"khepri_path.html#t:unix_path/0","title":"khepri_path.unix_path/0","type":"type"},{"doc":"Unix-like path pattern to a node. It accepts the following special characters: * anywhere in a path component behaves like a khepri_condition:if_name_matches() . ** as a path component behaves like a khepri_condition:if_path_matches() . A Unix-like path pattern can't express all the conditions of a native path pattern currently. Otherwise it works as a unix_path() and has the same syntax and limitations. Example: %% Unix path pattern, matching multiple types of oak. UnixPathPattern = &quot;/:stock/:wood/*oak&quot; .","ref":"khepri_path.html#t:unix_pattern/0","title":"khepri_path.unix_pattern/0","type":"type"},{"doc":"Khepri payloads. Payloads are the structure used to attach something to a tree node in the store. Khepri supports the following payloads: No payload at all ( no_payload() Data payload used to store any Erlang term ( data() ) Stored procedure payload used to store functions ( sproc() ) Usually, there is no need to explicitly use this module as the type of payload will be autodetected, thanks to the wrap/1 function already called internally.","ref":"khepri_payload.html","title":"khepri_payload","type":"module"},{"doc":"Returns the same term wrapped into an internal structure ready to be stored in the tree. See also: data() .","ref":"khepri_payload.html#data/1","title":"khepri_payload.data/1","type":"function"},{"doc":"Returns the internal value used to mark that a tree node has no payload attached. See also: no_payload() .","ref":"khepri_payload.html#none/0","title":"khepri_payload.none/0","type":"function"},{"doc":"Returns the same function wrapped into an internal structure ready to be stored in the tree. See also: sproc() .","ref":"khepri_payload.html#sproc/1","title":"khepri_payload.sproc/1","type":"function"},{"doc":"Automatically detects the payload type and ensures it is wrapped in one of the internal types. The internal types make sure we avoid any collision between any user-provided terms and internal structures.","ref":"khepri_payload.html#wrap/1","title":"khepri_payload.wrap/1","type":"function"},{"doc":"Internal structure to wrap any Erlang term before it can be stored in a tree node. The only constraint is the conversion to an Erlang binary must be supported by this term.","ref":"khepri_payload.html#t:data/0","title":"khepri_payload.data/0","type":"type"},{"doc":"Internal value used to mark that a tree node has no payload attached.","ref":"khepri_payload.html#t:no_payload/0","title":"khepri_payload.no_payload/0","type":"type"},{"doc":"All types of payload stored in the nodes of the tree structure. Beside the absence of payload, the only type of payload supported is data.","ref":"khepri_payload.html#t:payload/0","title":"khepri_payload.payload/0","type":"type"},{"doc":"Internal structure to wrap an anonymous function before it can be stored in a tree node and later executed.","ref":"khepri_payload.html#t:sproc/0","title":"khepri_payload.sproc/0","type":"type"},{"doc":"","ref":"khepri_sproc.html","title":"khepri_sproc","type":"module"},{"doc":"","ref":"khepri_sproc.html#run/2","title":"khepri_sproc.run/2","type":"function"},{"doc":"","ref":"khepri_sproc.html#to_standalone_fun/1","title":"khepri_sproc.to_standalone_fun/1","type":"function"},{"doc":"","ref":"khepri_sup.html","title":"khepri_sup","type":"module"},{"doc":"","ref":"khepri_sup.html#init/1","title":"khepri_sup.init/1","type":"function"},{"doc":"","ref":"khepri_sup.html#start_link/0","title":"khepri_sup.start_link/0","type":"function"},{"doc":"Khepri API for transactional queries and updates. Transactions are anonymous functions which take no arguments, much like what Mnesia supports. However, unlike with Mnesia, transaction functions in Khepri are restricted: Calls to BIFs and other functions is limited to a set of whitelisted APIs. See is_remote_call_valid/3 for the complete list. Sending or receiving messages is denied. The reason is that the transaction function must always have the exact same outcome given its inputs. Indeed, the transaction function is executed on every Ra cluster members participating in the consensus. The function must therefore modify the Khepri state (the database) identically on all Ra members. This is also true for Ra members joining the cluster later or catching up after a network partition. To achieve that: The code of the transaction function is extracted from the its initial Erlang module. This way, the transaction function does not depend on the initial module availability and is not affected by a module reload. See khepri_fun ) The code is verified to make sure it does not perform any denied operations. The extracted transaction function is stored as a Khepri state machine command in the Ra journal to be replicated on all Ra members. Functions in this module have simplified return values to cover most frequent use cases. If you need more details about the queried or modified tree nodes, like the ability to distinguish a non-existent tree node from a tree node with no payload, you can use the khepri_tx_adv module.","ref":"khepri_tx.html","title":"khepri_tx","type":"module"},{"doc":"Aborts the transaction. Any changes so far are not committed to the store. khepri:transaction/1 and friends will return tx_abort() .","ref":"khepri_tx.html#abort/1","title":"khepri_tx.abort/1","type":"function"},{"doc":"Updates an existing tree node with the given payload only if its data matches the given pattern. This is the same as khepri:compare_and_swap/4 but inside the context of a transaction function. See also: khepri:compare_and_swap/4 .","ref":"khepri_tx.html#compare_and_swap/3","title":"khepri_tx.compare_and_swap/3","type":"function"},{"doc":"Updates an existing tree node with the given payload only if its data matches the given pattern. This is the same as khepri:compare_and_swap/5 but inside the context of a transaction function. See also: khepri:compare_and_swap/5 .","ref":"khepri_tx.html#compare_and_swap/4","title":"khepri_tx.compare_and_swap/4","type":"function"},{"doc":"Counts all tree nodes matching the given path pattern. This is the same as khepri:count/2 but inside the context of a transaction function. See also: khepri:count/2 .","ref":"khepri_tx.html#count/1","title":"khepri_tx.count/1","type":"function"},{"doc":"Counts all tree nodes matching the given path pattern. This is the same as khepri:count/3 but inside the context of a transaction function. See also: khepri:count/3 .","ref":"khepri_tx.html#count/2","title":"khepri_tx.count/2","type":"function"},{"doc":"Creates a tree node with the given payload. This is the same as khepri:create/3 but inside the context of a transaction function. See also: khepri:create/3 .","ref":"khepri_tx.html#create/2","title":"khepri_tx.create/2","type":"function"},{"doc":"Creates a tree node with the given payload. This is the same as khepri:create/4 but inside the context of a transaction function. See also: khepri:create/4 .","ref":"khepri_tx.html#create/3","title":"khepri_tx.create/3","type":"function"},{"doc":"Deletes the tree node pointed to by the given path pattern. This is the same as khepri:delete/2 but inside the context of a transaction function. See also: khepri:delete/2 .","ref":"khepri_tx.html#delete/1","title":"khepri_tx.delete/1","type":"function"},{"doc":"Deletes the tree node pointed to by the given path pattern. This is the same as khepri:delete/3 but inside the context of a transaction function. See also: khepri:delete/3 .","ref":"khepri_tx.html#delete/2","title":"khepri_tx.delete/2","type":"function"},{"doc":"Deletes all tree nodes matching the given path pattern. This is the same as khepri:delete_many/2 but inside the context of a transaction function. See also: khepri:delete_many/2 .","ref":"khepri_tx.html#delete_many/1","title":"khepri_tx.delete_many/1","type":"function"},{"doc":"Deletes all tree nodes matching the given path pattern. This is the same as khepri:delete_many/3 but inside the context of a transaction function. See also: khepri:delete_many/3 .","ref":"khepri_tx.html#delete_many/2","title":"khepri_tx.delete_many/2","type":"function"},{"doc":"Deletes the payload of all tree nodes matching the given path pattern. This is the same as khepri:delete_many_payloads/2 but inside the context of a transaction function. See also: khepri:delete_many_payloads/2 .","ref":"khepri_tx.html#delete_many_payloads/1","title":"khepri_tx.delete_many_payloads/1","type":"function"},{"doc":"Deletes the payload of all tree nodes matching the given path pattern. This is the same as khepri:delete_many_payloads/3 but inside the context of a transaction function. See also: khepri:delete_many_payloads/3 .","ref":"khepri_tx.html#delete_many_payloads/2","title":"khepri_tx.delete_many_payloads/2","type":"function"},{"doc":"Deletes the payload of the tree node pointed to by the given path pattern. This is the same as khepri:delete_payload/2 but inside the context of a transaction function. See also: khepri:delete_payload/2 .","ref":"khepri_tx.html#delete_payload/1","title":"khepri_tx.delete_payload/1","type":"function"},{"doc":"Deletes the payload of the tree node pointed to by the given path pattern. This is the same as khepri:delete_payload/3 but inside the context of a transaction function. See also: khepri:delete_payload/3 .","ref":"khepri_tx.html#delete_payload/2","title":"khepri_tx.delete_payload/2","type":"function"},{"doc":"Indicates if the tree node pointed to by the given path exists or not. This is the same as khepri:exists/2 but inside the context of a transaction function. See also: khepri:exists/2 .","ref":"khepri_tx.html#exists/1","title":"khepri_tx.exists/1","type":"function"},{"doc":"Indicates if the tree node pointed to by the given path exists or not. This is the same as khepri:exists/3 but inside the context of a transaction function. See also: khepri:exists/3 .","ref":"khepri_tx.html#exists/2","title":"khepri_tx.exists/2","type":"function"},{"doc":"Returns the payload of the tree node pointed to by the given path pattern. This is the same as khepri:get/2 but inside the context of a transaction function. See also: khepri:get/2 .","ref":"khepri_tx.html#get/1","title":"khepri_tx.get/1","type":"function"},{"doc":"Returns the payload of the tree node pointed to by the given path pattern. This is the same as khepri:get/3 but inside the context of a transaction function. See also: khepri:get/3 .","ref":"khepri_tx.html#get/2","title":"khepri_tx.get/2","type":"function"},{"doc":"Returns payloads of all the tree nodes matching the given path pattern. This is the same as khepri:get_many/2 but inside the context of a transaction function. See also: khepri:get_many/2 .","ref":"khepri_tx.html#get_many/1","title":"khepri_tx.get_many/1","type":"function"},{"doc":"Returns payloads of all the tree nodes matching the given path pattern. This is the same as khepri:get_many/3 but inside the context of a transaction function. See also: khepri:get_many/3 .","ref":"khepri_tx.html#get_many/2","title":"khepri_tx.get_many/2","type":"function"},{"doc":"Returns payloads of all the tree nodes matching the given path pattern, or a default payload. This is the same as khepri:get_many_or/3 but inside the context of a transaction function. See also: khepri:get_many_or/3 .","ref":"khepri_tx.html#get_many_or/2","title":"khepri_tx.get_many_or/2","type":"function"},{"doc":"Returns payloads of all the tree nodes matching the given path pattern, or a default payload. This is the same as khepri:get_many_or/4 but inside the context of a transaction function. See also: khepri:get_many_or/4 .","ref":"khepri_tx.html#get_many_or/3","title":"khepri_tx.get_many_or/3","type":"function"},{"doc":"Returns the payload of the tree node pointed to by the given path pattern, or a default value. This is the same as khepri:get_or/3 but inside the context of a transaction function. See also: khepri:get_or/3 .","ref":"khepri_tx.html#get_or/2","title":"khepri_tx.get_or/2","type":"function"},{"doc":"Returns the payload of the tree node pointed to by the given path pattern, or a default value. This is the same as khepri:get_or/4 but inside the context of a transaction function. See also: khepri:get_or/4 .","ref":"khepri_tx.html#get_or/3","title":"khepri_tx.get_or/3","type":"function"},{"doc":"Indicates if the tree node pointed to by the given path has data or not. This is the same as khepri:has_data/2 but inside the context of a transaction function. See also: khepri:has_data/2 .","ref":"khepri_tx.html#has_data/1","title":"khepri_tx.has_data/1","type":"function"},{"doc":"Indicates if the tree node pointed to by the given path has data or not. This is the same as khepri:has_data/3 but inside the context of a transaction function. See also: khepri:has_data/3 .","ref":"khepri_tx.html#has_data/2","title":"khepri_tx.has_data/2","type":"function"},{"doc":"Indicates if the tree node pointed to by the given path holds a stored procedure or not. This is the same as khepri:is_sproc/2 but inside the context of a transaction function. See also: khepri:is_sproc/2 .","ref":"khepri_tx.html#is_sproc/1","title":"khepri_tx.is_sproc/1","type":"function"},{"doc":"Indicates if the tree node pointed to by the given path holds a stored procedure or not. This is the same as khepri:is_sproc/3 but inside the context of a transaction function. See also: khepri:is_sproc/3 .","ref":"khepri_tx.html#is_sproc/2","title":"khepri_tx.is_sproc/2","type":"function"},{"doc":"Indicates if the calling function runs in the context of a transaction function.","ref":"khepri_tx.html#is_transaction/0","title":"khepri_tx.is_transaction/0","type":"function"},{"doc":"Runs the stored procedure pointed to by the given path and returns the result. This is the same as khepri:put/3 but inside the context of a transaction function. See also: khepri:put/3 .","ref":"khepri_tx.html#put/2","title":"khepri_tx.put/2","type":"function"},{"doc":"Runs the stored procedure pointed to by the given path and returns the result. This is the same as khepri:put/4 but inside the context of a transaction function. See also: khepri:put/4 .","ref":"khepri_tx.html#put/3","title":"khepri_tx.put/3","type":"function"},{"doc":"Sets the payload of all the tree nodes matching the given path pattern. This is the same as khepri:put_many/3 but inside the context of a transaction function. See also: khepri:put_many/3 .","ref":"khepri_tx.html#put_many/2","title":"khepri_tx.put_many/2","type":"function"},{"doc":"Sets the payload of all the tree nodes matching the given path pattern. This is the same as khepri:put_many/4 but inside the context of a transaction function. See also: khepri:put_many/4 .","ref":"khepri_tx.html#put_many/3","title":"khepri_tx.put_many/3","type":"function"},{"doc":"Updates an existing tree node with the given payload. This is the same as khepri:update/3 but inside the context of a transaction function. See also: khepri:update/3 .","ref":"khepri_tx.html#update/2","title":"khepri_tx.update/2","type":"function"},{"doc":"Updates an existing tree node with the given payload. This is the same as khepri:update/4 but inside the context of a transaction function. See also: khepri:update/4 .","ref":"khepri_tx.html#update/3","title":"khepri_tx.update/3","type":"function"},{"doc":"Return value after a transaction function aborted.","ref":"khepri_tx.html#t:tx_abort/0","title":"khepri_tx.tx_abort/0","type":"type"},{"doc":"Transaction function signature.","ref":"khepri_tx.html#t:tx_fun/0","title":"khepri_tx.tx_fun/0","type":"type"},{"doc":"Return value of a transaction function.","ref":"khepri_tx.html#t:tx_fun_result/0","title":"khepri_tx.tx_fun_result/0","type":"type"},{"doc":"Khepri advanced API for transactional queries and updates. This module exposes variants of the functions in khepri_tx which return more detailed return values for advanced use cases. See khepri_adv for examples of use cases where this module could be useful.","ref":"khepri_tx_adv.html","title":"khepri_tx_adv","type":"module"},{"doc":"Updates an existing tree node with the given payload only if its data matches the given pattern. This is the same as khepri_adv:compare_and_swap/4 but inside the context of a transaction function. See also: khepri_adv:compare_and_swap/4 .","ref":"khepri_tx_adv.html#compare_and_swap/3","title":"khepri_tx_adv.compare_and_swap/3","type":"function"},{"doc":"Updates an existing tree node with the given payload only if its data matches the given pattern. This is the same as khepri_adv:compare_and_swap/5 but inside the context of a transaction function. See also: khepri_adv:compare_and_swap/5 .","ref":"khepri_tx_adv.html#compare_and_swap/4","title":"khepri_tx_adv.compare_and_swap/4","type":"function"},{"doc":"Creates a tree node with the given payload. This is the same as khepri_adv:create/3 but inside the context of a transaction function. See also: khepri_adv:create/3 .","ref":"khepri_tx_adv.html#create/2","title":"khepri_tx_adv.create/2","type":"function"},{"doc":"Creates a tree node with the given payload. This is the same as khepri_adv:create/4 but inside the context of a transaction function. See also: khepri_adv:create/4 .","ref":"khepri_tx_adv.html#create/3","title":"khepri_tx_adv.create/3","type":"function"},{"doc":"Deletes the tree node pointed to by the given path pattern. This is the same as khepri_adv:delete/2 but inside the context of a transaction function. See also: khepri_adv:delete/2 .","ref":"khepri_tx_adv.html#delete/1","title":"khepri_tx_adv.delete/1","type":"function"},{"doc":"Deletes the tree node pointed to by the given path pattern. This is the same as khepri_adv:delete/3 but inside the context of a transaction function. See also: khepri_adv:delete/3 .","ref":"khepri_tx_adv.html#delete/2","title":"khepri_tx_adv.delete/2","type":"function"},{"doc":"Deletes all tree nodes matching the given path pattern. This is the same as khepri_adv:delete_many/2 but inside the context of a transaction function. See also: khepri_adv:delete_many/2 .","ref":"khepri_tx_adv.html#delete_many/1","title":"khepri_tx_adv.delete_many/1","type":"function"},{"doc":"Deletes all tree nodes matching the given path pattern. This is the same as khepri_adv:delete_many/3 but inside the context of a transaction function. See also: khepri_adv:delete_many/3 .","ref":"khepri_tx_adv.html#delete_many/2","title":"khepri_tx_adv.delete_many/2","type":"function"},{"doc":"Deletes the payload of all tree nodes matching the given path pattern. This is the same as khepri_adv:delete_many_payloads/2 but inside the context of a transaction function. See also: khepri_adv:delete_many_payloads/2 .","ref":"khepri_tx_adv.html#delete_many_payloads/1","title":"khepri_tx_adv.delete_many_payloads/1","type":"function"},{"doc":"Deletes the payload of all tree nodes matching the given path pattern. This is the same as khepri_adv:delete_many_payloads/3 but inside the context of a transaction function. See also: khepri_adv:delete_many_payloads/3 .","ref":"khepri_tx_adv.html#delete_many_payloads/2","title":"khepri_tx_adv.delete_many_payloads/2","type":"function"},{"doc":"Deletes the payload of the tree node pointed to by the given path pattern. This is the same as khepri_adv:delete_payload/2 but inside the context of a transaction function. See also: khepri_adv:delete_payload/2 .","ref":"khepri_tx_adv.html#delete_payload/1","title":"khepri_tx_adv.delete_payload/1","type":"function"},{"doc":"Deletes the payload of the tree node pointed to by the given path pattern. This is the same as khepri_adv:delete_payload/3 but inside the context of a transaction function. See also: khepri_adv:delete_payload/3 .","ref":"khepri_tx_adv.html#delete_payload/2","title":"khepri_tx_adv.delete_payload/2","type":"function"},{"doc":"Returns the payload of the tree node pointed to by the given path pattern. This is the same as khepri_adv:get/2 but inside the context of a transaction function. See also: khepri_adv:get/2 .","ref":"khepri_tx_adv.html#get/1","title":"khepri_tx_adv.get/1","type":"function"},{"doc":"Returns the payload of the tree node pointed to by the given path pattern. This is the same as khepri_adv:get/3 but inside the context of a transaction function. See also: khepri_adv:get/3 .","ref":"khepri_tx_adv.html#get/2","title":"khepri_tx_adv.get/2","type":"function"},{"doc":"Returns payloads of all the tree nodes matching the given path pattern. This is the same as khepri_adv:get_many/2 but inside the context of a transaction function. See also: khepri_adv:get_many/2 .","ref":"khepri_tx_adv.html#get_many/1","title":"khepri_tx_adv.get_many/1","type":"function"},{"doc":"Returns payloads of all the tree nodes matching the given path pattern. This is the same as khepri_adv:get_many/3 but inside the context of a transaction function. See also: khepri_adv:get_many/3 .","ref":"khepri_tx_adv.html#get_many/2","title":"khepri_tx_adv.get_many/2","type":"function"},{"doc":"Runs the stored procedure pointed to by the given path and returns the result. This is the same as khepri_adv:put/3 but inside the context of a transaction function. See also: khepri_adv:put/3 .","ref":"khepri_tx_adv.html#put/2","title":"khepri_tx_adv.put/2","type":"function"},{"doc":"Runs the stored procedure pointed to by the given path and returns the result. This is the same as khepri_adv:put/4 but inside the context of a transaction function. See also: khepri_adv:put/4 .","ref":"khepri_tx_adv.html#put/3","title":"khepri_tx_adv.put/3","type":"function"},{"doc":"Sets the payload of all the tree nodes matching the given path pattern. This is the same as khepri_adv:put_many/3 but inside the context of a transaction function. See also: khepri_adv:put_many/3 .","ref":"khepri_tx_adv.html#put_many/2","title":"khepri_tx_adv.put_many/2","type":"function"},{"doc":"Sets the payload of all the tree nodes matching the given path pattern. This is the same as khepri_adv:put_many/4 but inside the context of a transaction function. See also: khepri_adv:put_many/4 .","ref":"khepri_tx_adv.html#put_many/3","title":"khepri_tx_adv.put_many/3","type":"function"},{"doc":"Updates an existing tree node with the given payload. This is the same as khepri_adv:update/3 but inside the context of a transaction function. See also: khepri_adv:update/3 .","ref":"khepri_tx_adv.html#update/2","title":"khepri_tx_adv.update/2","type":"function"},{"doc":"Updates an existing tree node with the given payload. This is the same as khepri_adv:update/4 but inside the context of a transaction function. See also: khepri_adv:update/4 .","ref":"khepri_tx_adv.html#update/3","title":"khepri_tx_adv.update/3","type":"function"},{"doc":"","ref":"khepri_tx_adv.html#t:tx_props/0","title":"khepri_tx_adv.tx_props/0","type":"type"},{"doc":"","ref":"khepri_utils.html","title":"khepri_utils","type":"module"},{"doc":"","ref":"khepri_utils.html#clear_list_of_modules_to_skip/0","title":"khepri_utils.clear_list_of_modules_to_skip/0","type":"function"},{"doc":"","ref":"khepri_utils.html#display_tree/1","title":"khepri_utils.display_tree/1","type":"function"},{"doc":"","ref":"khepri_utils.html#display_tree/2","title":"khepri_utils.display_tree/2","type":"function"},{"doc":"","ref":"khepri_utils.html#display_tree/3","title":"khepri_utils.display_tree/3","type":"function"},{"doc":"","ref":"khepri_utils.html#end_timeout_window/2","title":"khepri_utils.end_timeout_window/2","type":"function"},{"doc":"","ref":"khepri_utils.html#flat_struct_to_tree/1","title":"khepri_utils.flat_struct_to_tree/1","type":"function"},{"doc":"","ref":"khepri_utils.html#format_exception/4","title":"khepri_utils.format_exception/4","type":"function"},{"doc":"","ref":"khepri_utils.html#init_list_of_modules_to_skip/0","title":"khepri_utils.init_list_of_modules_to_skip/0","type":"function"},{"doc":"","ref":"khepri_utils.html#is_ra_server_alive/1","title":"khepri_utils.is_ra_server_alive/1","type":"function"},{"doc":"","ref":"khepri_utils.html#should_collect_code_for_module/1","title":"khepri_utils.should_collect_code_for_module/1","type":"function"},{"doc":"","ref":"khepri_utils.html#sleep/2","title":"khepri_utils.sleep/2","type":"function"},{"doc":"","ref":"khepri_utils.html#start_timeout_window/1","title":"khepri_utils.start_timeout_window/1","type":"function"},{"doc":"","ref":"khepri_utils.html#t:display_tree/0","title":"khepri_utils.display_tree/0","type":"type"},{"doc":"Khepri is a tree-like replicated on-disk database library for Erlang and Elixir. Data are stored in a tree structure . Each node in the tree is referenced by its path from the root node. A path is a list of Erlang atoms and/or binaries. For ease of use, Unix-like path strings are accepted as well. For consistency and replication and to manage data on disk, Khepri relies on Ra , an Erlang implementation of the Raft consensus algorithm . In Ra parlance, Khepri is a state machine in a Ra cluster. This page describes all the concepts in Khepri and points the reader to the modules' documentation for more details.","ref":"overview.html","title":"The Khepri Database","type":"extras"},{"doc":"This started as an experiment to replace how data (other than message bodies) are stored in the RabbitMQ messaging broker . Before Khepri, those data were stored and replicated to cluster members using Mnesia. Mnesia is very handy and powerful: It comes out-of-the-box with the Erlang runtime and standard library. It does all the heavy lifting and RabbitMQ just uses it as a key/value store without thinking too much about replication. However, recovering from any network partitions is quite difficult. This was the primary reason why the RabbitMQ team started to explore other options. Because RabbitMQ already uses an implementation of the Raft consensus algorithm for its quorum queues, it was decided to leverage that library for all metadata. That's how Khepri was borne. Thanks to Ra and Raft, it is clear how Khepri will behave during a network partition and recover from it . This makes it more comfortable for the RabbitMQ team and users, thanks to the absence of unknowns. At the time of this writing, RabbitMQ does not use Khepri in a production release yet because this library and its integration into RabbitMQ are still a work in progress.","ref":"overview.html#why-khepri","title":"The Khepri Database - Why Khepri?","type":"extras"},{"doc":"Tree nodes Data in Khepri are organized as tree nodes ( khepri_machine:tree_node() ) in a tree structure. Every tree node has: a node ID a payload (optional) properties o | +-- orders | `-- stock | `-- wood |-- &lt;&lt;&quot;mapple&quot;&gt;&gt; = 12 `-- &lt;&lt;&quot;oak&quot;&gt;&gt; = 41 Node ID A tree node name is either an Erlang atom or an Erlang binary ( khepri_path:node_id() ). Payload A tree node may or may not have a payload. Khepri supports two types of payload, the data payload and the stored procedure payload . More payload types may be added in the future. When passed to khepri:put/2 , the type of the payload is autodetected. However if you need to prepare the payload before passing it to Khepri, you can use the following functions: khepri_payload:none/0 khepri_payload:data/1 khepri_payload:sproc/1 Properties Properties are: The version of the payload, tracking the number of times it was modified ( khepri:payload_version() ). The version of the list of child nodes, tracking the number of times child nodes were added or removed ( khepri:child_list_version() ). The number of child nodes ( khepri:child_list_length() ). Addressing a tree node The equivalent of a key in a key/value store is a path ( khepri_path:path() ) in Khepri. A path is a list of node IDs, from the root (unnamed) tree node to the target ( khepri_path:path() ). For instance: %% Points to &quot;/:stock/:wood/oak&quot; in the tree shown above: Path = [ stock , wood , &lt;&lt; &quot;oak&quot; &gt;&gt; ] . It is possible to target multiple tree nodes at once by using a path pattern ( khepri_path:pattern() ). In addition to node IDs, path patterns have conditions ( khepri_condition:condition() ). Conditions allow things like: checking the existence of a tree node targeting all child nodes of a tree node matching on node IDs using a regex matching on the data payload For instance: %% Matches all varieties of wood in the stock: PathPattern = [ stock , wood , # if_node_matches { regex = any } ] . %% Matches the supplier of oak if there is an active order: PathPattern = [ order , wood , # if_all { conditions = [ &lt;&lt; &quot;oak&quot; &gt;&gt; , # if_data_matches { pattern = { active , true } } ] } , supplier ] . Finally, a path can use some special path component names, handy when using relative paths: ?THIS_NODE to point to self ?PARENT_NODE to point to the parent tree node ?ROOT_NODE to explicitly point to the root unnamed node Relative paths are useful when putting conditions on tree node lifetimes . Tree node lifetime A tree node's lifetime starts when it is inserted the first time and ends when it is removed from the tree. However, intermediary tree nodes created on the way remain in the tree long after the leaf node was removed. For instance, when [stock, wood, &lt;&lt;&quot;walnut&quot;&gt;&gt;] was inserted, the intermediary tree nodes stock and wood were created if they were missing. After &lt;&lt;&quot;walnut&quot;&gt;&gt; is removed, they will stay in the tree with possibly neither payload nor child nodes. Khepri has the concept of keep_while conditions . A keep_while condition is like the conditions which can be used inside path pattern. When a node is inserted or updated, it is possible to set keep_while conditions: when these conditions evaluate to false, the tree node is removed from the tree. For instance, it is possible to set the following condition on [stock, wood] to make sure it is removed after its last child node is removed: %% We keep [stock, wood] as long as its child nodes count is strictly greater %% than zero. KeepWhileCondition = \#{ [ stock , wood ] =&gt; # if_child_list_length { count = { gt , 0 } } } . keep_while conditions on self (like the example above) are not evaluated on the first insert though.","ref":"overview.html#the-tree-structure","title":"The Khepri Database - The tree structure","type":"extras"},{"doc":"A Khepri store corresponds to one Ra cluster. In fact, the name of the Ra cluster is the name of the Khepri store. It is possible to have multiple database instances running on the same Erlang node or cluster by starting multiple Ra clusters. Note that it is called a &quot;cluster&quot; but it can have a single member. You can start a Khepri store using khepri:start/0 up to khepri:start/3 . See those functions to learn more about the configuration settings. To expand or shrink a cluster, khepri_cluster:join/1 and khepri_cluster:reset/0 allow a Khepri store node to join or leave a cluster.","ref":"overview.html#stores","title":"The Khepri Database - Stores","type":"extras"},{"doc":"The essential part of the public API is provided by the khepri module. It covers most common use cases and should be straightforward to use. ok = khepri : put ( [ stock , wood , &lt;&lt; &quot;lime tree&quot; &gt;&gt; ] , 150 ) , { ok , 150 } = khepri : get ( [ stock , wood , &lt;&lt; &quot;lime tree&quot; &gt;&gt; ] ) , true = khepri : exists ( [ stock , wood , &lt;&lt; &quot;lime tree&quot; &gt;&gt; ] ) , ok = khepri : delete ( [ stock , wood , &lt;&lt; &quot;lime tree&quot; &gt;&gt; ] ) . Inside transaction functions, khepri_tx must be used instead of khepri . The former provides the same API, except for functions which don't make sense in the context of a transaction function. khepri and khepri_tx both have counterparts for more advanced use cases, khepri_adv and khepri_tx_adv . The return values of the *_adv modules are maps giving more details about what was queried or modified. The public API is built on top of a low-level internal API, provided by the private khepri_machine module.","ref":"overview.html#khepri-api","title":"The Khepri Database - Khepri API","type":"extras"},{"doc":"Restrictions On the surface, Khepri transactions look like Mnesia ones: they are anonymous functions which can do any arbitrary operations on the data and return any result. If something goes wrong or the anonymous function aborts, nothing is committed and the database is left untouched as if the transaction code was never called. Under the hood, there are several restrictions and caveats that need to be understood in order to use transactions in Khepri: If the anonymous function only reads data from the tree, there is no specific restrictions on them. If however the anonymous function needs to modify or delete data from the database, then the constraints described in the next section need to be taken into account. The nature of the anonymous function is passed as the ReadWrite argument to khepri:transaction/3 . The constraints imposed by Raft The Raft algorithm is used to achieve consensus among Khepri members participating in the database. Khepri is a state machine executed on each Ra node and all instances of that Khepri state machine start with the same state and modify it identically. The goal is that, after the same list of Ra commands, all instances have the same state. When a new Ra node joins the cluster and therefore participates to the Khepri database, it starts a new Khepri state machine instance. This instance needs to apply all Ra commands from an initial state to be on the same page as other existing instances. Likewise, if for any reason, one of the Khepri state machine instance looses the connection to other members and can't apply Ra commands, then when the link comes back, it has to catch up. All this means that the code to modify the state of the state machines (i.e. the tree) needs to run on all instances, possibly not at the same time, and give the exact same result everywhere. The problem with anonymous functions This is fine for inserts and deletes because the code is part of Khepri and is deterministic. This poses a problem when transactions are anonymous functions outside of Khepri's control: Khepri must be able to store the anonymous function as a Ra command in Ra's log. This is the basis for replication and is mandatory to add a new cluster member or for a lagging member to catch up. The anonymous function must produce exactly the same result in all state machine instances, regardless of the time it runs, the availability of other Erlang modules, the state of Erlang processes, files on disk or network connections, and so on. To achieve that, khepri_fun and khepri_tx extract the assembly code of the anonymous function and create a standalone Erlang module based on it. This module can be stored in Ra's log and executed anywhere without the presence of the initial anonymous function's module. Here is what they do in more details: The assembly code of the module hosting the anonymous function is extracted. The anonymous function code is located inside that assembly code. The code is analyzed to determine: that it does not perform any forbidden operations (sending or receiving inter-process messages, use date and time, access files or network connections, etc.) what other functions it calls Based on the listed function calls, the same steps are repeated for all of them (extract, verify, list calls). Once all the assembly code to have a standalone anonymous function is collected, an Erlang module is generated. How to handle side effects? The consequence of the above constraints is that a transaction function can't depend on anything else than the tree and it can't have any side effects outside of the changes to the tree nodes. If the transaction needs to have side effects, there are two options: Perform any side effects after the transaction. Use khepri:put/3 with khepri_condition:if_payload_version() conditions in the path and retry if the put fails because the version changed in between. Here is an example of the second option: Path = [ stock , wood , &lt;&lt; &quot;lime tree&quot; &gt;&gt; ] , { ok , \#{ data := Term , payload_version := PayloadVersion } } = khepri_adv : get ( StoredId , Path ) , %% Do anything with `Term` that depend on external factors and could have side %% effects. Term1 = do_something_with_side_effects ( Term ) , PathPattern = [ stock , wood , # if_all { conditions = [ &lt;&lt; &quot;lime tree&quot; &gt;&gt; , # if_payload_version { version = PayloadVersion } ] } ] , case khepri : put ( StoredId , PathPattern , Term1 ) of ok -&gt; ok ; %% `Term1` was stored successfully. { error , ? khepri_error ( mismatching_node , _ ) } -&gt; loop ( ) %% Restart the whole function to read/modify/write again. end .","ref":"overview.html#transactions","title":"The Khepri Database - Transactions","type":"extras"},{"doc":"Triggering a function after some event It is possible to associate events with an anonymous function to trigger its execution when something happens. This is what is usually called a trigger in databases and Khepri supports this feature. Currently, Khepri supports a single type of event, tree changes . This event is emitted whenever a tree node is being created, updated or deleted. Here is a summary of what happens when such an event is emitted: Khepri looks up any event filters which could match the emitted event. If one or more event filters are found, their corresponding stored procedures are executed. The indicated stored procedure must have been stored in the tree first. Storing an anonymous function This is possible to store an anonymous function as the payload of a tree node: khepri : put ( StoreId , StoredProcPath , fun ( ) -&gt; do_something ( ) end ) . The StoredProcPath can be any path in the tree . Unlike transaction functions, a stored procedure has no restrictions on what it is allowed to do. Therefore, a stored procedure can send or receive messages, read or write from a disk, generate random numbers and so on. A stored procedure can accept any numbers of arguments too. It is possible to execute a stored procedure directly without configuring any triggers. To execute a stored procedure, you can call khepri:run_sproc/3 . Here is an example: Ret = khepri : run_sproc ( StoreId , StoredProcPath , [ ] = _ Args ) . This works exactly like erlang:apply/2 . The list of arguments passed to khepri:run_sproc/3 must correspond to the stored procedure arity. Configuring a trigger Khepri uses event filters to associate a type of events with a stored procedure. Khepri supports tree changes events and thus only supports a single event filter called khepri_evf:tree_event_filter() . An event filter is registered using khepri:register_trigger/4 : %% An event filter can be explicitly created using the `khepri_evf&#39; %% module. This is possible to specify properties at the same time. EventFilter = khepri_evf : tree ( [ stock , wood , &lt;&lt; &quot;oak&quot; &gt;&gt; ] , %% Required \#{ on_actions =&gt; [ delete ] , %% Optional priority =&gt; 10 } ) , %% Optional %% For ease of use, some terms can be automatically converted to an event %% filter. Here, a Unix-like path could be used as a tree event filter, though %% it would have default properties unlike the previous line: EventFilter = &quot;/:stock/:wood/oak&quot; . ok = khepri : register_trigger ( StoreId , TriggerId , EventFilter , StoredProcPath ) . In this example, the khepri_evf:tree_event_filter() structure only requires the path to monitor. The path can be any path pattern and thus can have conditions to monitor several nodes at once. The on_actions property is optional. By default the event filter matches all tree changes ( create , update or delete ). The priority property is also optional and defaults to 0. When several event filters match a given event, they are sorted by priority (a greater integer means the event filter will be considered first), then by TriggerId in alphabetical order. Neither the monitored path nor the stored procedure (pointed to by StoredProcPath ) need to exist when the event filter is registered. If the stored procedure doesn't exist when an event occurs, the event filter is simply ignored. A stored procedure can change after an event filter is registered as well. The stored procedure used for a trigger must accept a single argument, a map containing properties of the emitted event: my_stored_procedure ( Props ) -&gt; \#{ path := Path , on_action := Action } = Props . Path is the path to the tree node created, updated or deleted. Action is the nature of the change ( create , update or delete ). The return value of this stored procedure is ignored in the context of a trigger. Execution guarantees The stored procedure associated with a trigger (event filter) is executed on the Ra leader node. If the stored procedure throws an exception, it is logged and there is no retry. There is an internal ack mechanism to make sure the stored procedure is executed at least once. Therefore, if the Ra leader changes before the execution of the stored procedure could be confirmed to the Khepri state machine, the execution will be retried on the new Ra leader. This means that the stored procedure could be executed multiple times. Therefore it is important it is idempotent. Differences with triggers in RDBMS As described earlier, the rationale for triggers in Khepri is that sometimes, one needs to execute some code with side effects (e.g. sending a message to a process) after a record was modified in the database. This can't happen in a transaction because side effects are forbidden. The caller could handle that after he modifies the record, but the record could be indirectly modified (deleted) as a consequence of another record being modified or deleted. In this case, the caller can't do anything. Because of the freedom they need, triggers are not allowed to mess with the database directly . In other words, they must go through the regular Khepri API like any caller. Triggers do not have any privileges or blanket approvals to tamper with the data. So even though Khepri uses the same naming than many RDBMS, triggers in Khepri can't have unexpected consequences.","ref":"overview.html#stored-procedures-and-triggers","title":"The Khepri Database - Stored procedures and triggers","type":"extras"}]