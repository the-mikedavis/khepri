<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.28.5">
    <meta name="project" content="khepri v0.4.3">

    <title>The Khepri Database — khepri v0.4.3</title>
    <link rel="stylesheet" href="dist/html-erlang-C3352F33.css" />

    <script src="dist/handlebars.runtime-NWIB6V2M.js"></script>
    <script src="dist/handlebars.templates-X7YVL3G2.js"></script>
    <script src="dist/sidebar_items-FD7723E7.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/html-PLW5RNNI.js"></script>


  </head>
  <body data-type="extras" class="page-extra">
    <script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script>

<div class="main">

<button class="sidebar-button sidebar-toggle" aria-label="toggle sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <i class="ri-search-2-line" aria-hidden="true" title="Submit search"></i>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <i class="ri-close-line ri-lg" aria-hidden="true" title="Cancel search"></i>
    </button>
    <label class="search-label">
      <p class="sr-only">Search</p>
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">

      <a href="overview.html">
        <img src="assets/logo.svg" alt="khepri" class="sidebar-projectImage">
      </a>

    <div class="sidebar-projectDetails">
      <a href="overview.html" class="sidebar-projectName" translate="no">
khepri
      </a>
      <strong class="sidebar-projectVersion" translate="no">
        v0.4.3
      </strong>
    </div>
    <ul class="sidebar-listNav">
      <li><a id="extras-list-link" href="#full-list">Pages</a></li>

        <li><a id="modules-list-link" href="#full-list">Modules</a></li>


    </ul>
  </div>

  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <output role="status" id="toast"></output>
  <div class="content-outer">
    <div id="content" class="content-inner">

<h1>
<button class="settings display-settings">
  <i class="ri-settings-3-line"></i>
  <span class="sr-only">Settings</span>
</button>


  <span>The Khepri Database</span>
</h1>

<p>Khepri is a tree-like replicated on-disk database library for Erlang and
Elixir.</p><p>Data are stored in a <strong>tree structure</strong>. Each node in the tree is referenced by
its path from the root node. A path is a list of Erlang atoms and/or binaries.
For ease of use, Unix-like path strings are accepted as well.</p><p>For <strong>consistency and replication</strong> and to manage data on disk,
Khepri relies on <a href="https://github.com/rabbitmq/ra">Ra</a>, an Erlang
implementation of the <a href="https://raft.github.io">Raft consensus algorithm</a>.
In Ra parlance, Khepri is a state machine in a Ra cluster.</p><p>This page <strong>describes all the concepts in Khepri</strong> and points the
reader to the modules' documentation for more details.</p><h2 id="why-khepri" class="section-heading">
  <a href="#why-khepri" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">why-khepri</p>
  </a>
  Why Khepri?
</h2>
<p>This started as an experiment to replace how data (other than message bodies)
are stored in the <a href="https://www.rabbitmq.com/">RabbitMQ messaging broker</a>.
Before Khepri, those data were stored and replicated to cluster members using
Mnesia.</p><p>Mnesia is very handy and powerful:</p><ul><li>It comes out-of-the-box with the Erlang runtime and standard library.</li><li>It does all the heavy lifting and RabbitMQ just uses it as a key/value
store without thinking too much about replication.</li></ul><p>However, recovering from any network partitions is quite difficult. This was
the primary reason why the RabbitMQ team started to explore other options.</p><p>Because RabbitMQ already uses an implementation of the Raft consensus algorithm
for its quorum queues, it was decided to leverage that library for all
metadata. That's how Khepri was borne.</p><p>Thanks to Ra and Raft, it is <strong>clear how Khepri will behave during a
network partition and recover from it</strong>. This makes it more comfortable
for the RabbitMQ team and users, thanks to the absence of unknowns.</p><blockquote><p>At the time of this writing, RabbitMQ does not use Khepri in a production
release yet because this library and its integration into RabbitMQ are still
a work in progress.</p></blockquote><h2 id="the-tree-structure" class="section-heading">
  <a href="#the-tree-structure" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">the-tree-structure</p>
  </a>
  The tree structure
</h2>
<h3 id="tree-nodes" class="section-heading">
  <a href="#tree-nodes" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">tree-nodes</p>
  </a>
  Tree nodes
</h3>
<p>Data in Khepri are organized as <em>tree nodes</em>
(<a href="khepri_machine.html#t:tree_node/0"><code class="inline">khepri_machine:tree_node()</code></a>) in a tree structure. Every tree node has:</p><ul><li>a <a href="#node-id">node ID</a></li><li>a <a href="#payload">payload</a> (optional)</li><li><a href="#properties">properties</a></li></ul><pre><code class="none">o
|
+-- orders
|
`-- stock
    |
    `-- wood
        |-- &lt;&lt;&quot;mapple&quot;&gt;&gt; = 12
        `-- &lt;&lt;&quot;oak&quot;&gt;&gt; = 41</code></pre><h3 id="node-id" class="section-heading">
  <a href="#node-id" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">node-id</p>
  </a>
  Node ID
</h3>
<p>A tree node name is either an Erlang atom or an Erlang binary
(<a href="khepri_path.html#t:node_id/0"><code class="inline">khepri_path:node_id()</code></a>).</p><h3 id="payload" class="section-heading">
  <a href="#payload" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">payload</p>
  </a>
  Payload
</h3>
<p>A tree node may or may not have a payload. Khepri supports two types of
payload, the <em>data payload</em> and the <em>stored procedure payload</em>.
More payload types may be added in the future.</p><p>When passed to <a href="khepri.html#put/2"><code class="inline">khepri:put/2</code></a>, the type of the payload is autodetected.
However if you need to prepare the payload before passing it to Khepri, you can
use the following functions:</p><ul><li><a href="khepri_payload.html#none/0"><code class="inline">khepri_payload:none/0</code></a></li><li><a href="khepri_payload.html#data/1"><code class="inline">khepri_payload:data/1</code></a></li><li><a href="khepri_payload.html#sproc/1"><code class="inline">khepri_payload:sproc/1</code></a></li></ul><h3 id="properties" class="section-heading">
  <a href="#properties" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">properties</p>
  </a>
  Properties
</h3>
<p>Properties are:</p><ul><li>The version of the payload, tracking the number of times it was modified
(<a href="khepri.html#t:payload_version/0"><code class="inline">khepri:payload_version()</code></a>).</li><li>The version of the list of child nodes, tracking the number of times child
nodes were added or removed (<a href="khepri.html#t:child_list_version/0"><code class="inline">khepri:child_list_version()</code></a>).</li><li>The number of child nodes (<a href="khepri.html#t:child_list_length/0"><code class="inline">khepri:child_list_length()</code></a>).</li></ul><h3 id="addressing-a-tree-node" class="section-heading">
  <a href="#addressing-a-tree-node" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">addressing-a-tree-node</p>
  </a>
  Addressing a tree node
</h3>
<p>The equivalent of a <em>key</em> in a key/value store is a <em>path</em>
(<a href="khepri_path.html#t:path/0"><code class="inline">khepri_path:path()</code></a>) in Khepri.</p><p>A path is a list of node IDs, from the root (unnamed) tree node to the target
(<a href="khepri_path.html#t:path/0"><code class="inline">khepri_path:path()</code></a>). For instance:</p><pre><code class="makeup erlang" translate="no"><span class="c1">%% Points to &quot;/:stock/:wood/oak&quot; in the tree shown above:</span><span class="w">
</span><span class="n">Path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="7650324556-1">[</span><span class="ss">stock</span><span class="p">,</span><span class="w"> </span><span class="ss">wood</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;&lt;</span><span class="s">&quot;oak&quot;</span><span class="p">&gt;&gt;</span><span class="p" data-group-id="7650324556-1">]</span><span class="p">.</span></code></pre><p>It is possible to target multiple tree nodes at once by using a <em>path
pattern</em> (<a href="khepri_path.html#t:pattern/0"><code class="inline">khepri_path:pattern()</code></a>). In addition to node IDs, path
patterns have conditions (<a href="khepri_condition.html#t:condition/0"><code class="inline">khepri_condition:condition()</code></a>). Conditions allow
things like:</p><ul><li>checking the existence of a tree node</li><li>targeting all child nodes of a tree node</li><li>matching on node IDs using a regex</li><li>matching on the data payload</li></ul><p>For instance:</p><pre><code class="makeup erlang" translate="no"><span class="c1">%% Matches all varieties of wood in the stock:</span><span class="w">
</span><span class="n">PathPattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8413127405-1">[</span><span class="ss">stock</span><span class="p">,</span><span class="w"> </span><span class="ss">wood</span><span class="p">,</span><span class="w"> </span><span class="o">#</span><span class="ss">if_node_matches</span><span class="p" data-group-id="8413127405-2">{</span><span class="ss">regex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">any</span><span class="p" data-group-id="8413127405-2">}</span><span class="p" data-group-id="8413127405-1">]</span><span class="p">.</span><span class="w">

</span><span class="c1">%% Matches the supplier of oak if there is an active order:</span><span class="w">
</span><span class="n">PathPattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8413127405-3">[</span><span class="ss">order</span><span class="p">,</span><span class="w">
               </span><span class="ss">wood</span><span class="p">,</span><span class="w">
               </span><span class="o">#</span><span class="ss">if_all</span><span class="p" data-group-id="8413127405-4">{</span><span class="ss">conditions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8413127405-5">[</span><span class="w">
                 </span><span class="p">&lt;&lt;</span><span class="s">&quot;oak&quot;</span><span class="p">&gt;&gt;</span><span class="p">,</span><span class="w">
                 </span><span class="o">#</span><span class="ss">if_data_matches</span><span class="p" data-group-id="8413127405-6">{</span><span class="ss">pattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8413127405-7">{</span><span class="ss">active</span><span class="p">,</span><span class="w"> </span><span class="ss">true</span><span class="p" data-group-id="8413127405-7">}</span><span class="p" data-group-id="8413127405-6">}</span><span class="p" data-group-id="8413127405-5">]</span><span class="p" data-group-id="8413127405-4">}</span><span class="p">,</span><span class="w">
               </span><span class="ss">supplier</span><span class="p" data-group-id="8413127405-3">]</span><span class="p">.</span></code></pre><p>Finally, a path can use some special path component names, handy when using
relative paths:</p><ul><li><code class="inline">?THIS_NODE</code> to point to self</li><li><code class="inline">?PARENT_NODE</code> to point to the parent tree node</li><li><code class="inline">?ROOT_NODE</code> to explicitly point to the root unnamed node</li></ul><p>Relative paths are useful when putting conditions on
<a href="#tree-node-lifetime">tree node lifetimes</a>.</p><h3 id="tree-node-lifetime" class="section-heading">
  <a href="#tree-node-lifetime" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">tree-node-lifetime</p>
  </a>
  Tree node lifetime
</h3>
<p>A tree node's lifetime starts when it is inserted the first time and ends when
it is removed from the tree. However, intermediary tree nodes created on the
way remain in the tree long after the leaf node was removed.</p><p>For instance, when <code class="inline">[stock, wood, &lt;&lt;&quot;walnut&quot;&gt;&gt;]</code> was inserted, the intermediary
tree nodes <code class="inline">stock</code> and <code class="inline">wood</code> were created if they were missing. After
<code class="inline">&lt;&lt;&quot;walnut&quot;&gt;&gt;</code> is removed, they will stay in the tree with possibly neither
payload nor child nodes.</p><p>Khepri has the concept of <em><code class="inline">keep_while</code> conditions</em>. A <code class="inline">keep_while</code>
condition is like the conditions which can be used inside path pattern. When a
node is inserted or updated, it is possible to set <code class="inline">keep_while</code> conditions:
when these conditions evaluate to false, the tree node is removed from the
tree.</p><p>For instance, it is possible to set the following condition on <code class="inline">[stock, wood]</code>
to make sure it is removed after its last child node is removed:</p><pre><code class="makeup erlang" translate="no"><span class="c1">%% We keep [stock, wood] as long as its child nodes count is strictly greater</span><span class="w">
</span><span class="c1">%% than zero.</span><span class="w">
</span><span class="n">KeepWhileCondition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8519729839-1">#{</span><span class="p" data-group-id="8519729839-2">[</span><span class="ss">stock</span><span class="p">,</span><span class="w"> </span><span class="ss">wood</span><span class="p" data-group-id="8519729839-2">]</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="o">#</span><span class="ss">if_child_list_length</span><span class="p" data-group-id="8519729839-3">{</span><span class="ss">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8519729839-4">{</span><span class="ss">gt</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="8519729839-4">}</span><span class="p" data-group-id="8519729839-3">}</span><span class="p" data-group-id="8519729839-1">}</span><span class="p">.</span></code></pre><p><code class="inline">keep_while</code> conditions on self (like the example above) are not evaluated on
the first insert though.</p><h2 id="stores" class="section-heading">
  <a href="#stores" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">stores</p>
  </a>
  Stores
</h2>
<p>A Khepri store corresponds to one Ra cluster. In fact, the name of the Ra
cluster is the name of the Khepri store. It is possible to have multiple
database instances running on the same Erlang node or cluster by starting
multiple Ra clusters. Note that it is called a &quot;cluster&quot; but it can have a
single member.</p><p>You can start a Khepri store using <a href="khepri.html#start/0"><code class="inline">khepri:start/0</code></a> up to <a href="khepri.html#start/3"><code class="inline">khepri:start/3</code></a>.
See those functions to learn more about the configuration settings.</p><p>To expand or shrink a cluster, <a href="khepri_cluster.html#join/1"><code class="inline">khepri_cluster:join/1</code></a> and
<a href="khepri_cluster.html#reset/0"><code class="inline">khepri_cluster:reset/0</code></a> allow a Khepri store node to join or leave a cluster.</p><h2 id="khepri-api" class="section-heading">
  <a href="#khepri-api" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">khepri-api</p>
  </a>
  Khepri API
</h2>
<p>The essential part of the public API is provided by the <a href="khepri.html"><code class="inline">khepri</code></a> module.
It covers most common use cases and should be straightforward to use.</p><pre><code class="makeup erlang" translate="no"><span class="ss">ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">khepri</span><span class="p">:</span><span class="nf">put</span><span class="p" data-group-id="1366275275-1">(</span><span class="p" data-group-id="1366275275-2">[</span><span class="ss">stock</span><span class="p">,</span><span class="w"> </span><span class="ss">wood</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;&lt;</span><span class="s">&quot;lime tree&quot;</span><span class="p">&gt;&gt;</span><span class="p" data-group-id="1366275275-2">]</span><span class="p">,</span><span class="w"> </span><span class="mi">150</span><span class="p" data-group-id="1366275275-1">)</span><span class="p">,</span><span class="w">

</span><span class="p" data-group-id="1366275275-3">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="mi">150</span><span class="p" data-group-id="1366275275-3">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">khepri</span><span class="p">:</span><span class="nf">get</span><span class="p" data-group-id="1366275275-4">(</span><span class="p" data-group-id="1366275275-5">[</span><span class="ss">stock</span><span class="p">,</span><span class="w"> </span><span class="ss">wood</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;&lt;</span><span class="s">&quot;lime tree&quot;</span><span class="p">&gt;&gt;</span><span class="p" data-group-id="1366275275-5">]</span><span class="p" data-group-id="1366275275-4">)</span><span class="p">,</span><span class="w">

</span><span class="ss">true</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">khepri</span><span class="p">:</span><span class="nf">exists</span><span class="p" data-group-id="1366275275-6">(</span><span class="p" data-group-id="1366275275-7">[</span><span class="ss">stock</span><span class="p">,</span><span class="w"> </span><span class="ss">wood</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;&lt;</span><span class="s">&quot;lime tree&quot;</span><span class="p">&gt;&gt;</span><span class="p" data-group-id="1366275275-7">]</span><span class="p" data-group-id="1366275275-6">)</span><span class="p">,</span><span class="w">

</span><span class="ss">ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">khepri</span><span class="p">:</span><span class="nf">delete</span><span class="p" data-group-id="1366275275-8">(</span><span class="p" data-group-id="1366275275-9">[</span><span class="ss">stock</span><span class="p">,</span><span class="w"> </span><span class="ss">wood</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;&lt;</span><span class="s">&quot;lime tree&quot;</span><span class="p">&gt;&gt;</span><span class="p" data-group-id="1366275275-9">]</span><span class="p" data-group-id="1366275275-8">)</span><span class="p">.</span></code></pre><p>Inside transaction functions, <a href="khepri_tx.html"><code class="inline">khepri_tx</code></a> must be used instead of <a href="khepri.html"><code class="inline">khepri</code></a>.
The former provides the same API, except for functions which don't
make sense in the context of a transaction function.</p><p><a href="khepri.html"><code class="inline">khepri</code></a> and <a href="khepri_tx.html"><code class="inline">khepri_tx</code></a> both have counterparts for more advanced use cases,
<a href="khepri_adv.html"><code class="inline">khepri_adv</code></a> and <a href="khepri_tx_adv.html"><code class="inline">khepri_tx_adv</code></a>. The return values of the <code class="inline">*_adv</code> modules
are maps giving more details about what was queried or modified.</p><p>The public API is built on top of a low-level internal API, provided by the
private <a href="khepri_machine.html"><code class="inline">khepri_machine</code></a> module.</p><h2 id="transactions" class="section-heading">
  <a href="#transactions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">transactions</p>
  </a>
  Transactions
</h2>
<h3 id="restrictions" class="section-heading">
  <a href="#restrictions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">restrictions</p>
  </a>
  Restrictions
</h3>
<p>On the surface, Khepri transactions look like Mnesia ones: they are anonymous
functions which can do any arbitrary operations on the data and return any
result. If something goes wrong or the anonymous function aborts, nothing is
committed and the database is left untouched as if the transaction code was
never called.</p><p>Under the hood, there are several restrictions and caveats that need to be
understood in order to use transactions in Khepri:</p><ul><li>If the anonymous function only <strong>reads data</strong> from the tree,
there is no specific restrictions on them.</li><li>If however the anonymous function needs to <strong>modify or
delete</strong> data from the database, then the constraints described in the
next section need to be taken into account.</li></ul><p>The nature of the anonymous function is passed as the <code class="inline">ReadWrite</code> argument to
<a href="khepri.html#transaction/3"><code class="inline">khepri:transaction/3</code></a>.</p><h3 id="the-constraints-imposed-by-raft" class="section-heading">
  <a href="#the-constraints-imposed-by-raft" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">the-constraints-imposed-by-raft</p>
  </a>
  The constraints imposed by Raft
</h3>
<p>The Raft algorithm is used to achieve consensus among Khepri members
participating in the database. Khepri is a state machine executed on each Ra
node and all instances of that Khepri state machine start with the same state
and modify it identically. The goal is that, after the same list of Ra
commands, all instances have the same state.</p><p>When a new Ra node joins the cluster and therefore participates to the Khepri
database, it starts a new Khepri state machine instance. This instance needs to
apply all Ra commands from an initial state to be on the same page as other
existing instances.</p><p>Likewise, if for any reason, one of the Khepri state machine instance looses
the connection to other members and can't apply Ra commands, then when the link
comes back, it has to catch up.</p><p>All this means that the code to modify the state of the state machines (i.e.
the tree) needs to run on all instances, possibly not at the same time, and
give the exact same result everywhere.</p><h3 id="the-problem-with-anonymous-functions" class="section-heading">
  <a href="#the-problem-with-anonymous-functions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">the-problem-with-anonymous-functions</p>
  </a>
  The problem with anonymous functions
</h3>
<p>This is fine for inserts and deletes because the code is part of Khepri and is
deterministic. This poses a problem when transactions are anonymous functions
outside of Khepri's control:</p><ol><li>Khepri must be able to store the anonymous function as a Ra command in Ra's
log. This is the basis for replication and is mandatory to add a new cluster
member or for a lagging member to catch up.</li><li>The anonymous function must produce exactly the same result in all state
machine instances, regardless of the time it runs, the availability of other
Erlang modules, the state of Erlang processes, files on disk or network
connections, and so on.</li></ol><p>To achieve that, <a href="khepri_fun.html"><code class="inline">khepri_fun</code></a> and <a href="khepri_tx.html"><code class="inline">khepri_tx</code></a> extract the assembly code of
the anonymous function and create a standalone Erlang module based on it. This
module can be stored in Ra's log and executed anywhere without the presence of
the initial anonymous function's module.</p><p>Here is what they do in more details:</p><ol><li>The assembly code of the module hosting the anonymous function is
extracted.</li><li>The anonymous function code is located inside that assembly code.</li><li>The code is analyzed to determine:<ul><li>that it does not perform any forbidden operations (sending or receiving
inter-process messages, use date and time, access files or network
connections, etc.)</li><li>what other functions it calls</li></ul></li><li>Based on the listed function calls, the same steps are repeated for all of
them (extract, verify, list calls).</li><li>Once all the assembly code to have a standalone anonymous function is
collected, an Erlang module is generated.</li></ol><h3 id="how-to-handle-side-effects" class="section-heading">
  <a href="#how-to-handle-side-effects" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">how-to-handle-side-effects</p>
  </a>
  How to handle side effects?
</h3>
<p>The consequence of the above constraints is that a transaction function can't
depend on anything else than the tree and it can't have any side effects
outside of the changes to the tree nodes.</p><p>If the transaction needs to have side effects, there are two options:</p><ul><li>Perform any side effects after the transaction.</li><li>Use <a href="khepri.html#put/3"><code class="inline">khepri:put/3</code></a> with <a href="khepri_condition.html#t:if_payload_version/0"><code class="inline">khepri_condition:if_payload_version()</code></a>
conditions in the path and retry if the put fails because the version changed
in between.</li></ul><p>Here is an example of the second option:</p><pre><code class="makeup erlang" translate="no"><span class="n">Path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="1959153100-1">[</span><span class="ss">stock</span><span class="p">,</span><span class="w"> </span><span class="ss">wood</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;&lt;</span><span class="s">&quot;lime tree&quot;</span><span class="p">&gt;&gt;</span><span class="p" data-group-id="1959153100-1">]</span><span class="p">,</span><span class="w">
</span><span class="p" data-group-id="1959153100-2">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1959153100-3">#{</span><span class="ss">data</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">Term</span><span class="p">,</span><span class="w">
       </span><span class="ss">payload_version</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">PayloadVersion</span><span class="p" data-group-id="1959153100-3">}</span><span class="p" data-group-id="1959153100-2">}</span><span class="w"> </span><span class="o">=</span><span class="w">
  </span><span class="nc">khepri_adv</span><span class="p">:</span><span class="nf">get</span><span class="p" data-group-id="1959153100-4">(</span><span class="n">StoredId</span><span class="p">,</span><span class="w"> </span><span class="n">Path</span><span class="p" data-group-id="1959153100-4">)</span><span class="p">,</span><span class="w">

</span><span class="c1">%% Do anything with `Term` that depend on external factors and could have side</span><span class="w">
</span><span class="c1">%% effects.</span><span class="w">
</span><span class="n">Term1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">do_something_with_side_effects</span><span class="p" data-group-id="1959153100-5">(</span><span class="n">Term</span><span class="p" data-group-id="1959153100-5">)</span><span class="p">,</span><span class="w">

</span><span class="n">PathPattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="1959153100-6">[</span><span class="ss">stock</span><span class="p">,</span><span class="w">
               </span><span class="ss">wood</span><span class="p">,</span><span class="w">
               </span><span class="o">#</span><span class="ss">if_all</span><span class="p" data-group-id="1959153100-7">{</span><span class="w">
                 </span><span class="ss">conditions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="1959153100-8">[</span><span class="w">
                   </span><span class="p">&lt;&lt;</span><span class="s">&quot;lime tree&quot;</span><span class="p">&gt;&gt;</span><span class="p">,</span><span class="w">
                   </span><span class="o">#</span><span class="ss">if_payload_version</span><span class="p" data-group-id="1959153100-9">{</span><span class="ss">version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PayloadVersion</span><span class="p" data-group-id="1959153100-9">}</span><span class="p" data-group-id="1959153100-8">]</span><span class="p" data-group-id="1959153100-7">}</span><span class="p" data-group-id="1959153100-6">]</span><span class="p">,</span><span class="w">
</span><span class="k">case</span><span class="w"> </span><span class="nc">khepri</span><span class="p">:</span><span class="nf">put</span><span class="p" data-group-id="1959153100-10">(</span><span class="n">StoredId</span><span class="p">,</span><span class="w"> </span><span class="n">PathPattern</span><span class="p">,</span><span class="w"> </span><span class="n">Term1</span><span class="p" data-group-id="1959153100-10">)</span><span class="w"> </span><span class="k">of</span><span class="w">
    </span><span class="ss">ok</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="ss">ok</span><span class="p">;</span><span class="w"> </span><span class="c1">%% `Term1` was stored successfully.</span><span class="w">
    </span><span class="p" data-group-id="1959153100-11">{</span><span class="ss">error</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="nf">khepri_error</span><span class="p" data-group-id="1959153100-12">(</span><span class="ss">mismatching_node</span><span class="p">,</span><span class="w"> </span><span class="p">_</span><span class="p" data-group-id="1959153100-12">)</span><span class="p" data-group-id="1959153100-11">}</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="nf">loop</span><span class="p" data-group-id="1959153100-13">(</span><span class="p" data-group-id="1959153100-13">)</span><span class="w"> </span><span class="c1">%% Restart the whole function to read/modify/write again.</span><span class="w">
</span><span class="k">end</span><span class="p">.</span></code></pre><h2 id="stored-procedures-and-triggers" class="section-heading">
  <a href="#stored-procedures-and-triggers" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">stored-procedures-and-triggers</p>
  </a>
  Stored procedures and triggers
</h2>
<h3 id="triggering-a-function-after-some-event" class="section-heading">
  <a href="#triggering-a-function-after-some-event" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">triggering-a-function-after-some-event</p>
  </a>
  Triggering a function after some event
</h3>
<p>It is possible to associate events with an anonymous function to trigger its
execution when something happens. This is what is usually called a
<em>trigger</em> in databases and Khepri supports this feature.</p><p>Currently, Khepri supports a single type of event, <em>tree changes</em>. This
event is emitted whenever a tree node is being created, updated or deleted.</p><p>Here is a summary of what happens when such an event is emitted:</p><ul><li>Khepri looks up any <em>event filters</em> which could match the emitted
event.</li><li>If one or more event filters are found, their corresponding stored
procedures are executed.</li></ul><p>The indicated stored procedure must have been stored in the tree first.</p><h3 id="storing-an-anonymous-function" class="section-heading">
  <a href="#storing-an-anonymous-function" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">storing-an-anonymous-function</p>
  </a>
  Storing an anonymous function
</h3>
<p>This is possible to store an anonymous function as the payload of a tree node:</p><pre><code class="makeup erlang" translate="no"><span class="nc">khepri</span><span class="p">:</span><span class="nf">put</span><span class="p" data-group-id="0496427531-1">(</span><span class="w">
  </span><span class="n">StoreId</span><span class="p">,</span><span class="w">
  </span><span class="n">StoredProcPath</span><span class="p">,</span><span class="w">
  </span><span class="nf">fun</span><span class="p" data-group-id="0496427531-2">(</span><span class="p" data-group-id="0496427531-2">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">do_something</span><span class="p" data-group-id="0496427531-3">(</span><span class="p" data-group-id="0496427531-3">)</span><span class="w"> </span><span class="k">end</span><span class="p" data-group-id="0496427531-1">)</span><span class="p">.</span></code></pre><p>The <code class="inline">StoredProcPath</code> can be <a href="#addressing-a-tree-node">any path in the tree</a>.</p><p>Unlike transaction functions, a stored procedure has no restrictions on what
it is allowed to do. Therefore, a stored procedure can send or receive
messages, read or write from a disk, generate random numbers and so on.</p><p>A stored procedure can accept any numbers of arguments too.</p><p>It is possible to execute a stored procedure directly without configuring any
triggers. To execute a stored procedure, you can call <a href="khepri.html#run_sproc/3"><code class="inline">khepri:run_sproc/3</code></a>.
Here is an example:</p><pre><code class="makeup erlang" translate="no"><span class="n">Ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">khepri</span><span class="p">:</span><span class="nf">run_sproc</span><span class="p" data-group-id="6066124216-1">(</span><span class="w">
        </span><span class="n">StoreId</span><span class="p">,</span><span class="w">
        </span><span class="n">StoredProcPath</span><span class="p">,</span><span class="w">
        </span><span class="p" data-group-id="6066124216-2">[</span><span class="p" data-group-id="6066124216-2">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">_</span><span class="n">Args</span><span class="p" data-group-id="6066124216-1">)</span><span class="p">.</span></code></pre><p>This works exactly like <a href="https://www.erlang.org/doc/man/erlang.html#apply-2"><code class="inline">erlang:apply/2</code></a>. The list of arguments passed
to <a href="khepri.html#run_sproc/3"><code class="inline">khepri:run_sproc/3</code></a> must correspond to the stored procedure
arity.</p><h3 id="configuring-a-trigger" class="section-heading">
  <a href="#configuring-a-trigger" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">configuring-a-trigger</p>
  </a>
  Configuring a trigger
</h3>
<p>Khepri uses <em>event filters</em> to associate a type of events with a stored
procedure. Khepri supports tree changes events and thus only supports a single
event filter called <a href="khepri_evf.html#t:tree_event_filter/0"><code class="inline">khepri_evf:tree_event_filter()</code></a>.</p><p>An event filter is registered using <a href="khepri.html#register_trigger/4"><code class="inline">khepri:register_trigger/4</code></a>:</p><pre><code class="makeup erlang" translate="no"><span class="c1">%% An event filter can be explicitly created using the `khepri_evf&#39;</span><span class="w">
</span><span class="c1">%% module. This is possible to specify properties at the same time.</span><span class="w">
</span><span class="n">EventFilter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">khepri_evf</span><span class="p">:</span><span class="nf">tree</span><span class="p" data-group-id="4742632430-1">(</span><span class="p" data-group-id="4742632430-2">[</span><span class="ss">stock</span><span class="p">,</span><span class="w"> </span><span class="ss">wood</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;&lt;</span><span class="s">&quot;oak&quot;</span><span class="p">&gt;&gt;</span><span class="p" data-group-id="4742632430-2">]</span><span class="p">,</span><span class="w"> </span><span class="c1">%% Required</span><span class="w">
                              </span><span class="p" data-group-id="4742632430-3">#{</span><span class="ss">on_actions</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p" data-group-id="4742632430-4">[</span><span class="ss">delete</span><span class="p" data-group-id="4742632430-4">]</span><span class="p">,</span><span class="w"> </span><span class="c1">%% Optional</span><span class="w">
                                </span><span class="ss">priority</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">10</span><span class="p" data-group-id="4742632430-3">}</span><span class="p" data-group-id="4742632430-1">)</span><span class="p">,</span><span class="w">       </span><span class="c1">%% Optional</span><span class="w">

</span><span class="c1">%% For ease of use, some terms can be automatically converted to an event</span><span class="w">
</span><span class="c1">%% filter. Here, a Unix-like path could be used as a tree event filter, though</span><span class="w">
</span><span class="c1">%% it would have default properties unlike the previous line:</span><span class="w">
</span><span class="n">EventFilter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;/:stock/:wood/oak&quot;</span><span class="p">.</span><span class="w">

</span><span class="ss">ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">khepri</span><span class="p">:</span><span class="nf">register_trigger</span><span class="p" data-group-id="4742632430-5">(</span><span class="w">
       </span><span class="n">StoreId</span><span class="p">,</span><span class="w">
       </span><span class="n">TriggerId</span><span class="p">,</span><span class="w">
       </span><span class="n">EventFilter</span><span class="p">,</span><span class="w">
       </span><span class="n">StoredProcPath</span><span class="p" data-group-id="4742632430-5">)</span><span class="p">.</span></code></pre><p>In this example, the <a href="khepri_evf.html#t:tree_event_filter/0"><code class="inline">khepri_evf:tree_event_filter()</code></a> structure only
requires the path to monitor. The path can be any path pattern and thus can
have conditions to monitor several nodes at once.</p><p>The <code class="inline">on_actions</code> property is optional. By default the event filter matches all
tree changes (<code class="inline">create</code>, <code class="inline">update</code> or <code class="inline">delete</code>).</p><p>The <code class="inline">priority</code> property is also optional and defaults to 0. When several event
filters match a given event, they are sorted by priority (a greater integer
means the event filter will be considered first), then by <code class="inline">TriggerId</code> in
alphabetical order.</p><p>Neither the monitored path nor the stored procedure (pointed to by
<code class="inline">StoredProcPath</code>) need to exist when the event filter is registered. If the
stored procedure doesn't exist when an event occurs, the event filter is
simply ignored. A stored procedure can change after an event filter is
registered as well.</p><p>The stored procedure used for a trigger must accept a single argument, a map
containing properties of the emitted event:</p><pre><code class="makeup erlang" translate="no"><span class="nf">my_stored_procedure</span><span class="p" data-group-id="9724999542-1">(</span><span class="n">Props</span><span class="p" data-group-id="9724999542-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="p" data-group-id="9724999542-2">#{</span><span class="ss">path</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">Path</span><span class="p">,</span><span class="w">
      </span><span class="ss">on_action</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">Action</span><span class="p" data-group-id="9724999542-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Props</span><span class="p">.</span></code></pre><p><code class="inline">Path</code> is the path to the tree node created, updated or deleted.</p><p><code class="inline">Action</code> is the nature of the change (<code class="inline">create</code>, <code class="inline">update</code> or <code class="inline">delete</code>).</p><p>The return value of this stored procedure is ignored in the context of a
trigger.</p><h3 id="execution-guarantees" class="section-heading">
  <a href="#execution-guarantees" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">execution-guarantees</p>
  </a>
  Execution guarantees
</h3>
<p>The stored procedure associated with a trigger (event filter) is executed on
the Ra leader node.</p><p>If the stored procedure throws an exception, it is logged and there is no
retry.</p><p>There is an internal ack mechanism to make sure the stored procedure is
executed at least once. Therefore, if the Ra leader changes before the
execution of the stored procedure could be confirmed to the Khepri state
machine, the execution will be retried on the new Ra leader.</p><p>This means that the stored procedure could be executed multiple times.
Therefore it is important it is idempotent.</p><h3 id="differences-with-triggers-in-rdbms" class="section-heading">
  <a href="#differences-with-triggers-in-rdbms" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">differences-with-triggers-in-rdbms</p>
  </a>
  Differences with triggers in RDBMS
</h3>
<p>As described earlier, the rationale for triggers in Khepri is that sometimes,
one needs to execute some code with side effects (e.g. sending a message to a
process) after a record was modified in the database. This can't happen in a
transaction because side effects are forbidden. The caller could handle that
after he modifies the record, but the record could be indirectly modified
(deleted) as a consequence of another record being modified or deleted. In
this case, the caller can't do anything.</p><p>Because of the freedom they need, <strong>triggers are not allowed to mess
with the database directly</strong>. In other words, they must go through the
regular Khepri API like any caller. Triggers do not have any privileges or
blanket approvals to tamper with the data.</p><p>So even though Khepri uses the same naming than many RDBMS, triggers in Khepri
can't have unexpected consequences.</p>
<div class="bottom-actions">
  <div class="bottom-actions-item">

      <a href="api-reference.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
API Reference
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

  </div>
</div>
      <footer class="footer">

          <p>
            On Hex.pm:

            <span class="line">
              <a href="https://hex.pm/packages/khepri/0.4.3" class="line footer-hex-package">Package</a>
              <a href="https://preview.hex.pm/preview/khepri/0.4.3" class="line">Preview</a>

                <a href="https://preview.hex.pm/preview/khepri/0.4.3/show/docs/overview.md">(current file)</a>

            </span>

            <button class="a-main line footer-button display-quick-switch">
              Search
            </button>
          </p>

        <p>
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.28.5) for the

            <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
